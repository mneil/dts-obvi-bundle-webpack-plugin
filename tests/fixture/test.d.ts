// Generated by dts-bundle-generator v7.0.0

/**
 * Trait marker for classes that can be depended upon
 *
 * The presence of this interface indicates that an object has
 * an `IDependable` implementation.
 *
 * This interface can be used to take an (ordering) dependency on a set of
 * constructs. An ordering dependency implies that the resources represented by
 * those constructs are deployed before the resources depending ON them are
 * deployed.
 */
export interface IDependable {
}
/**
 * An entry in the construct metadata table.
 */
export interface MetadataEntry {
	/**
	 * The metadata entry type.
	 */
	readonly type: string;
	/**
	 * The data.
	 */
	readonly data: any;
	/**
	 * Stack trace at the point of adding the metadata.
	 *
	 * Only available if `addMetadata()` is called with `stackTrace: true`.
	 *
	 * @default - no trace information
	 */
	readonly trace?: string[];
}
/**
 * Represents a construct.
 */
export interface IConstruct extends IDependable {
	/**
	 * The tree node.
	 */
	readonly node: Node;
}
declare class Node {
	private readonly host;
	/**
	 * Separator used to delimit construct path components.
	 */
	static readonly PATH_SEP = "/";
	/**
	 * Returns the node associated with a construct.
	 * @param construct the construct
	 *
	 * @deprecated use `construct.node` instead
	 */
	static of(construct: IConstruct): Node;
	/**
	 * Returns the scope in which this construct is defined.
	 *
	 * The value is `undefined` at the root of the construct scope tree.
	 */
	readonly scope?: IConstruct;
	/**
	 * The id of this construct within the current scope.
	 *
	 * This is a a scope-unique id. To obtain an app-unique id for this construct, use `addr`.
	 */
	readonly id: string;
	private _locked;
	private readonly _children;
	private readonly _context;
	private readonly _metadata;
	private readonly _dependencies;
	private _defaultChild;
	private readonly _validations;
	private _addr?;
	constructor(host: Construct, scope: IConstruct, id: string);
	/**
	 * The full, absolute path of this construct in the tree.
	 *
	 * Components are separated by '/'.
	 */
	get path(): string;
	/**
	 * Returns an opaque tree-unique address for this construct.
	 *
	 * Addresses are 42 characters hexadecimal strings. They begin with "c8"
	 * followed by 40 lowercase hexadecimal characters (0-9a-f).
	 *
	 * Addresses are calculated using a SHA-1 of the components of the construct
	 * path.
	 *
	 * To enable refactorings of construct trees, constructs with the ID `Default`
	 * will be excluded from the calculation. In those cases constructs in the
	 * same tree may have the same addreess.
	 *
	 * @example c83a2846e506bcc5f10682b564084bca2d275709ee
	 */
	get addr(): string;
	/**
	 * Return a direct child by id, or undefined
	 *
	 * @param id Identifier of direct child
	 * @returns the child if found, or undefined
	 */
	tryFindChild(id: string): IConstruct | undefined;
	/**
	 * Return a direct child by id
	 *
	 * Throws an error if the child is not found.
	 *
	 * @param id Identifier of direct child
	 * @returns Child with the given id.
	 */
	findChild(id: string): IConstruct;
	/**
	 * Returns the child construct that has the id `Default` or `Resource"`.
	 * This is usually the construct that provides the bulk of the underlying functionality.
	 * Useful for modifications of the underlying construct that are not available at the higher levels.
	 *
	 * @throws if there is more than one child
	 * @returns a construct or undefined if there is no default child
	 */
	get defaultChild(): IConstruct | undefined;
	/**
	 * Override the defaultChild property.
	 *
	 * This should only be used in the cases where the correct
	 * default child is not named 'Resource' or 'Default' as it
	 * should be.
	 *
	 * If you set this to undefined, the default behavior of finding
	 * the child named 'Resource' or 'Default' will be used.
	 */
	set defaultChild(value: IConstruct | undefined);
	/**
	 * All direct children of this construct.
	 */
	get children(): IConstruct[];
	/**
	 * Return this construct and all of its children in the given order
	 */
	findAll(order?: ConstructOrder): IConstruct[];
	/**
	 * This can be used to set contextual values.
	 * Context must be set before any children are added, since children may consult context info during construction.
	 * If the key already exists, it will be overridden.
	 * @param key The context key
	 * @param value The context value
	 */
	setContext(key: string, value: any): void;
	/**
	 * Retrieves a value from tree context.
	 *
	 * Context is usually initialized at the root, but can be overridden at any point in the tree.
	 *
	 * @param key The context key
	 * @returns The context value or `undefined` if there is no context value for thie key.
	 */
	tryGetContext(key: string): any;
	/**
	 * An immutable array of metadata objects associated with this construct.
	 * This can be used, for example, to implement support for deprecation notices, source mapping, etc.
	 */
	get metadata(): MetadataEntry[];
	/**
	 * Adds a metadata entry to this construct.
	 * Entries are arbitrary values and will also include a stack trace to allow tracing back to
	 * the code location for when the entry was added. It can be used, for example, to include source
	 * mapping in CloudFormation templates to improve diagnostics.
	 *
	 * @param type a string denoting the type of metadata
	 * @param data the value of the metadata (can be a Token). If null/undefined, metadata will not be added.
	 * @param options options
	 */
	addMetadata(type: string, data: any, options?: MetadataOptions): void;
	/**
	 * All parent scopes of this construct.
	 *
	 * @returns a list of parent scopes. The last element in the list will always
	 * be the current construct and the first element will be the root of the
	 * tree.
	 */
	get scopes(): IConstruct[];
	/**
	 * Returns the root of the construct tree.
	 * @returns The root of the construct tree.
	 */
	get root(): IConstruct;
	/**
	 * Returns true if this construct or the scopes in which it is defined are
	 * locked.
	 */
	get locked(): boolean;
	/**
	 * Add an ordering dependency on another construct.
	 *
	 * An `IDependable`
	 */
	addDependency(...deps: IDependable[]): void;
	/**
	 * Return all dependencies registered on this node (non-recursive).
	 */
	get dependencies(): IConstruct[];
	/**
	 * Remove the child with the given name, if present.
	 *
	 * @returns Whether a child with the given name was deleted.
	 * @experimental
	 */
	tryRemoveChild(childName: string): boolean;
	/**
	 * Adds a validation to this construct.
	 *
	 * When `node.validate()` is called, the `validate()` method will be called on
	 * all validations and all errors will be returned.
	 *
	 * @param validation The validation object
	 */
	addValidation(validation: IValidation): void;
	/**
	 * Validates this construct.
	 *
	 * Invokes the `validate()` method on all validations added through
	 * `addValidation()`.
	 *
	 * @returns an array of validation error messages associated with this
	 * construct.
	 */
	validate(): string[];
	/**
	 * Locks this construct from allowing more children to be added. After this
	 * call, no more children can be added to this construct or to any children.
	 */
	lock(): void;
	/**
	 * Adds a child construct to this node.
	 *
	 * @param child The child construct
	 * @param childName The type name of the child construct.
	 * @returns The resolved path part name of the child
	 */
	private addChild;
}
declare class Construct implements IConstruct {
	/**
	 * Checks if `x` is a construct.
	 *
	 * Use this method instead of `instanceof` to properly detect `Construct`
	 * instances, even when the construct library is symlinked.
	 *
	 * Explanation: in JavaScript, multiple copies of the `constructs` library on
	 * disk are seen as independent, completely different libraries. As a
	 * consequence, the class `Construct` in each copy of the `constructs` library
	 * is seen as a different class, and an instance of one class will not test as
	 * `instanceof` the other class. `npm install` will not create installations
	 * like this, but users may manually symlink construct libraries together or
	 * use a monorepo tool: in those cases, multiple copies of the `constructs`
	 * library can be accidentally installed, and `instanceof` will behave
	 * unpredictably. It is safest to avoid using `instanceof`, and using
	 * this type-testing method instead.
	 *
	 * @returns true if `x` is an object created from a class which extends `Construct`.
	 * @param x Any object
	 */
	static isConstruct(x: any): x is Construct;
	/**
	 * The tree node.
	 */
	readonly node: Node;
	/**
	 * Creates a new construct node.
	 *
	 * @param scope The scope in which to define this construct
	 * @param id The scoped construct ID. Must be unique amongst siblings. If
	 * the ID includes a path separator (`/`), then it will be replaced by double
	 * dash `--`.
	 */
	constructor(scope: Construct, id: string);
	/**
	 * Returns a string representation of this construct.
	 */
	toString(): string;
}
/**
 * Implement this interface in order for the construct to be able to validate itself.
 */
export interface IValidation {
	/**
	 * Validate the current construct.
	 *
	 * This method can be implemented by derived constructs in order to perform
	 * validation logic. It is called on all constructs before synthesis.
	 *
	 * @returns An array of validation error messages, or an empty array if there the construct is valid.
	 */
	validate(): string[];
}
declare enum ConstructOrder {
	/**
	 * Depth-first, pre-order
	 */
	PREORDER = 0,
	/**
	 * Depth-first, post-order (leaf nodes first)
	 */
	POSTORDER = 1
}
/**
 * Options for `construct.addMetadata()`.
 */
export interface MetadataOptions {
	/**
	 * Include stack trace with metadata entry.
	 * @default false
	 */
	readonly stackTrace?: boolean;
	/**
	 * A JavaScript function to begin tracing from.
	 *
	 * This option is ignored unless `stackTrace` is `true`.
	 *
	 * @default addMetadata()
	 */
	readonly traceFromFunction?: any;
}
/**
 * Information needed to access an IAM role created
 * as part of the bootstrap process
 */
export interface BootstrapRole {
	/**
	 * The ARN of the IAM role created as part of bootrapping
	 * e.g. lookupRoleArn
	 */
	readonly arn: string;
	/**
	 * External ID to use when assuming the bootstrap role
	 *
	 * @default - No external ID
	 */
	readonly assumeRoleExternalId?: string;
	/**
	 * Version of bootstrap stack required to use this role
	 *
	 * @default - No bootstrap stack required
	 */
	readonly requiresBootstrapStackVersion?: number;
	/**
	 * Name of SSM parameter with bootstrap stack version
	 *
	 * @default - Discover SSM parameter by reading stack
	 */
	readonly bootstrapStackVersionSsmParameter?: string;
}
/**
 * Artifact properties for CloudFormation stacks.
 */
export interface AwsCloudFormationStackProperties {
	/**
	 * A file relative to the assembly root which contains the CloudFormation template for this stack.
	 */
	readonly templateFile: string;
	/**
	 * Values for CloudFormation stack parameters that should be passed when the stack is deployed.
	 *
	 * @default - No parameters
	 */
	readonly parameters?: {
		[id: string]: string;
	};
	/**
	 * Values for CloudFormation stack tags that should be passed when the stack is deployed.
	 *
	 * @default - No tags
	 */
	readonly tags?: {
		[id: string]: string;
	};
	/**
	 * The name to use for the CloudFormation stack.
	 * @default - name derived from artifact ID
	 */
	readonly stackName?: string;
	/**
	 * Whether to enable termination protection for this stack.
	 *
	 * @default false
	 */
	readonly terminationProtection?: boolean;
	/**
	 * The role that needs to be assumed to deploy the stack
	 *
	 * @default - No role is assumed (current credentials are used)
	 */
	readonly assumeRoleArn?: string;
	/**
	 * External ID to use when assuming role for cloudformation deployments
	 *
	 * @default - No external ID
	 */
	readonly assumeRoleExternalId?: string;
	/**
	 * The role that is passed to CloudFormation to execute the change set
	 *
	 * @default - No role is passed (currently assumed role/credentials are used)
	 */
	readonly cloudFormationExecutionRoleArn?: string;
	/**
	 * The role to use to look up values from the target AWS account
	 *
	 * @default - No role is assumed (current credentials are used)
	 */
	readonly lookupRole?: BootstrapRole;
	/**
	 * If the stack template has already been included in the asset manifest, its asset URL
	 *
	 * @default - Not uploaded yet, upload just before deploying
	 */
	readonly stackTemplateAssetObjectUrl?: string;
	/**
	 * Version of bootstrap stack required to deploy this stack
	 *
	 * @default - No bootstrap stack required
	 */
	readonly requiresBootstrapStackVersion?: number;
	/**
	 * SSM parameter where the bootstrap stack version number can be found
	 *
	 * Only used if `requiresBootstrapStackVersion` is set.
	 *
	 * - If this value is not set, the bootstrap stack name must be known at
	 *   deployment time so the stack version can be looked up from the stack
	 *   outputs.
	 * - If this value is set, the bootstrap stack can have any name because
	 *   we won't need to look it up.
	 *
	 * @default - Bootstrap stack version number looked up
	 */
	readonly bootstrapStackVersionSsmParameter?: string;
	/**
	 * Whether this stack should be validated by the CLI after synthesis
	 *
	 * @default - false
	 */
	readonly validateOnSynth?: boolean;
}
/**
 * Configuration options for the Asset Manifest
 */
export interface AssetManifestOptions {
	/**
	 * Version of bootstrap stack required to deploy this stack
	 *
	 * @default - Version 1 (basic modern bootstrap stack)
	 */
	readonly requiresBootstrapStackVersion?: number;
	/**
	 * SSM parameter where the bootstrap stack version number can be found
	 *
	 * - If this value is not set, the bootstrap stack name must be known at
	 *   deployment time so the stack version can be looked up from the stack
	 *   outputs.
	 * - If this value is set, the bootstrap stack can have any name because
	 *   we won't need to look it up.
	 *
	 * @default - Bootstrap stack version number looked up
	 */
	readonly bootstrapStackVersionSsmParameter?: string;
}
/**
 * Artifact properties for the Asset Manifest
 */
export interface AssetManifestProperties extends AssetManifestOptions {
	/**
	 * Filename of the asset manifest
	 */
	readonly file: string;
}
/**
 * Artifact properties for the Construct Tree Artifact
 */
export interface TreeArtifactProperties {
	/**
	 * Filename of the tree artifact
	 */
	readonly file: string;
}
/**
 * Artifact properties for nested cloud assemblies
 */
export interface NestedCloudAssemblyProperties {
	/**
	 * Relative path to the nested cloud assembly
	 */
	readonly directoryName: string;
	/**
	 * Display name for the cloud assembly
	 *
	 * @default - The artifact ID
	 */
	readonly displayName?: string;
}
/**
 * Properties for manifest artifacts
 */
export declare type ArtifactProperties = AwsCloudFormationStackProperties | AssetManifestProperties | TreeArtifactProperties | NestedCloudAssemblyProperties;
/**
 * Common properties for asset metadata.
 */
export interface BaseAssetMetadataEntry {
	/**
	 * Requested packaging style
	 */
	readonly packaging: string;
	/**
	 * Logical identifier for the asset
	 */
	readonly id: string;
	/**
	 * The hash of the asset source.
	 */
	readonly sourceHash: string;
	/**
	 * Path on disk to the asset
	 */
	readonly path: string;
}
/**
 * Metadata Entry spec for files.
 */
export interface FileAssetMetadataEntry extends BaseAssetMetadataEntry {
	/**
	 * Requested packaging style
	 */
	readonly packaging: "zip" | "file";
	/**
	 * Name of parameter where S3 bucket should be passed in
	 */
	readonly s3BucketParameter: string;
	/**
	 * Name of parameter where S3 key should be passed in
	 */
	readonly s3KeyParameter: string;
	/**
	 * The name of the parameter where the hash of the bundled asset should be passed in.
	 */
	readonly artifactHashParameter: string;
}
/**
 * Metadata Entry spec for stack tag.
 */
export interface Tag {
	/**
	 * Tag key.
	 *
	 * (In the actual file on disk this will be cased as "Key", and the structure is
	 * patched to match this structure upon loading:
	 * https://github.com/aws/aws-cdk/blob/4aadaa779b48f35838cccd4e25107b2338f05547/packages/%40aws-cdk/cloud-assembly-schema/lib/manifest.ts#L137)
	 */
	readonly key: string;
	/**
	 * Tag value.
	 *
	 * (In the actual file on disk this will be cased as "Value", and the structure is
	 * patched to match this structure upon loading:
	 * https://github.com/aws/aws-cdk/blob/4aadaa779b48f35838cccd4e25107b2338f05547/packages/%40aws-cdk/cloud-assembly-schema/lib/manifest.ts#L137)
	 */
	readonly value: string;
}
/**
 * Metadata Entry spec for container images.
 */
export interface ContainerImageAssetMetadataEntry extends BaseAssetMetadataEntry {
	/**
	 * Type of asset
	 */
	readonly packaging: "container-image";
	/**
	 * ECR repository name, if omitted a default name based on the asset's ID is
	 * used instead. Specify this property if you need to statically address the
	 * image, e.g. from a Kubernetes Pod. Note, this is only the repository name,
	 * without the registry and the tag parts.
	 *
	 * @default - this parameter is REQUIRED after 1.21.0
	 */
	readonly repositoryName?: string;
	/**
	 * The docker image tag to use for tagging pushed images. This field is
	 * required if `imageParameterName` is ommited (otherwise, the app won't be
	 * able to find the image).
	 *
	 * @default - this parameter is REQUIRED after 1.21.0
	 */
	readonly imageTag?: string;
	/**
	 * Build args to pass to the `docker build` command
	 *
	 * @default no build args are passed
	 */
	readonly buildArgs?: {
		[key: string]: string;
	};
	/**
	 * Docker target to build to
	 *
	 * @default no build target
	 */
	readonly target?: string;
	/**
	 * Path to the Dockerfile (relative to the directory).
	 *
	 * @default - no file is passed
	 */
	readonly file?: string;
	/**
	 * Networking mode for the RUN commands during build.
	 *
	 * @default - no networking mode specified
	 */
	readonly networkMode?: string;
	/**
	 * Platform to build for. _Requires Docker Buildx_.
	 *
	 * @default - current machine platform
	 */
	readonly platform?: string;
}
/**
 * @see ArtifactMetadataEntryType.ASSET
 */
export declare type AssetMetadataEntry = FileAssetMetadataEntry | ContainerImageAssetMetadataEntry;
/**
 * @see ArtifactMetadataEntryType.INFO
 * @see ArtifactMetadataEntryType.WARN
 * @see ArtifactMetadataEntryType.ERROR
 */
export declare type LogMessageMetadataEntry = string;
/**
 * @see ArtifactMetadataEntryType.LOGICAL_ID
 */
export declare type LogicalIdMetadataEntry = string;
/**
 * @see ArtifactMetadataEntryType.STACK_TAGS
 */
export declare type StackTagsMetadataEntry = Tag[];
/**
 * Union type for all metadata entries that might exist in the manifest.
 */
export declare type MetadataEntryData = AssetMetadataEntry | LogMessageMetadataEntry | LogicalIdMetadataEntry | StackTagsMetadataEntry;
/**
 * A metadata entry in a cloud assembly artifact.
 */
export interface MetadataEntry {
	/**
	 * The type of the metadata entry.
	 */
	readonly type: string;
	/**
	 * The data.
	 *
	 * @default - no data.
	 */
	readonly data?: MetadataEntryData;
	/**
	 * A stack trace for when the entry was created.
	 *
	 * @default - no trace.
	 */
	readonly trace?: string[];
}
declare enum ContextProvider {
	/**
	 * AMI provider
	 */
	AMI_PROVIDER = "ami",
	/**
	 * AZ provider
	 */
	AVAILABILITY_ZONE_PROVIDER = "availability-zones",
	/**
	 * Route53 Hosted Zone provider
	 */
	HOSTED_ZONE_PROVIDER = "hosted-zone",
	/**
	 * SSM Parameter Provider
	 */
	SSM_PARAMETER_PROVIDER = "ssm",
	/**
	 * VPC Provider
	 */
	VPC_PROVIDER = "vpc-provider",
	/**
	 * VPC Endpoint Service AZ Provider
	 */
	ENDPOINT_SERVICE_AVAILABILITY_ZONE_PROVIDER = "endpoint-service-availability-zones",
	/**
	 * Load balancer provider
	 */
	LOAD_BALANCER_PROVIDER = "load-balancer",
	/**
	 * Load balancer listener provider
	 */
	LOAD_BALANCER_LISTENER_PROVIDER = "load-balancer-listener",
	/**
	 * Security group provider
	 */
	SECURITY_GROUP_PROVIDER = "security-group",
	/**
	 * KMS Key Provider
	 */
	KEY_PROVIDER = "key-provider",
	/**
	 * A plugin provider (the actual plugin name will be in the properties)
	 */
	PLUGIN = "plugin"
}
/**
 * Query to AMI context provider
 */
export interface AmiContextQuery {
	/**
	 * Account to query
	 */
	readonly account: string;
	/**
	 * Region to query
	 */
	readonly region: string;
	/**
	 * The ARN of the role that should be used to look up the missing values
	 *
	 * @default - None
	 */
	readonly lookupRoleArn?: string;
	/**
	 * Owners to DescribeImages call
	 *
	 * @default - All owners
	 */
	readonly owners?: string[];
	/**
	 * Filters to DescribeImages call
	 */
	readonly filters: {
		[key: string]: string[];
	};
}
/**
 * Query to availability zone context provider
 */
export interface AvailabilityZonesContextQuery {
	/**
	 * Query account
	 */
	readonly account: string;
	/**
	 * Query region
	 */
	readonly region: string;
	/**
	 * The ARN of the role that should be used to look up the missing values
	 *
	 * @default - None
	 */
	readonly lookupRoleArn?: string;
}
/**
 * Query to hosted zone context provider
 */
export interface HostedZoneContextQuery {
	/**
	 * Query account
	 */
	readonly account: string;
	/**
	 * Query region
	 */
	readonly region: string;
	/**
	 * The ARN of the role that should be used to look up the missing values
	 *
	 * @default - None
	 */
	readonly lookupRoleArn?: string;
	/**
	 * The domain name e.g. example.com to lookup
	 */
	readonly domainName: string;
	/**
	 * True if the zone you want to find is a private hosted zone
	 *
	 * @default false
	 */
	readonly privateZone?: boolean;
	/**
	 * The VPC ID to that the private zone must be associated with
	 *
	 * If you provide VPC ID and privateZone is false, this will return no results
	 * and raise an error.
	 *
	 * @default - Required if privateZone=true
	 */
	readonly vpcId?: string;
}
/**
 * Query to SSM Parameter Context Provider
 */
export interface SSMParameterContextQuery {
	/**
	 * Query account
	 */
	readonly account: string;
	/**
	 * Query region
	 */
	readonly region: string;
	/**
	 * The ARN of the role that should be used to look up the missing values
	 *
	 * @default - None
	 */
	readonly lookupRoleArn?: string;
	/**
	 * Parameter name to query
	 */
	readonly parameterName: string;
}
/**
 * Query input for looking up a VPC
 */
export interface VpcContextQuery {
	/**
	 * Query account
	 */
	readonly account: string;
	/**
	 * Query region
	 */
	readonly region: string;
	/**
	 * The ARN of the role that should be used to look up the missing values
	 *
	 * @default - None
	 */
	readonly lookupRoleArn?: string;
	/**
	 * Filters to apply to the VPC
	 *
	 * Filter parameters are the same as passed to DescribeVpcs.
	 *
	 * @see https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeVpcs.html
	 */
	readonly filter: {
		[key: string]: string;
	};
	/**
	 * Whether to populate the subnetGroups field of the {@link VpcContextResponse},
	 * which contains potentially asymmetric subnet groups.
	 *
	 * @default false
	 */
	readonly returnAsymmetricSubnets?: boolean;
	/**
	 * Optional tag for subnet group name.
	 * If not provided, we'll look at the aws-cdk:subnet-name tag.
	 * If the subnet does not have the specified tag,
	 * we'll use its type as the name.
	 *
	 * @default 'aws-cdk:subnet-name'
	 */
	readonly subnetGroupNameTag?: string;
}
/**
 * Query to endpoint service context provider
 */
export interface EndpointServiceAvailabilityZonesContextQuery {
	/**
	 * Query account
	 */
	readonly account: string;
	/**
	 * Query region
	 */
	readonly region: string;
	/**
	 * The ARN of the role that should be used to look up the missing values
	 *
	 * @default - None
	 */
	readonly lookupRoleArn?: string;
	/**
	 * Query service name
	 */
	readonly serviceName: string;
}
declare enum LoadBalancerType {
	/**
	 * Network load balancer
	 */
	NETWORK = "network",
	/**
	 * Application load balancer
	 */
	APPLICATION = "application"
}
/**
 * Filters for selecting load balancers
 */
export interface LoadBalancerFilter {
	/**
	 * Filter load balancers by their type
	 */
	readonly loadBalancerType: LoadBalancerType;
	/**
	 * Find by load balancer's ARN
	 * @default - does not search by load balancer arn
	 */
	readonly loadBalancerArn?: string;
	/**
	 * Match load balancer tags
	 * @default - does not match load balancers by tags
	 */
	readonly loadBalancerTags?: Tag[];
}
/**
 * Query input for looking up a load balancer
 */
export interface LoadBalancerContextQuery extends LoadBalancerFilter {
	/**
	 * Query account
	 */
	readonly account: string;
	/**
	 * Query region
	 */
	readonly region: string;
	/**
	 * The ARN of the role that should be used to look up the missing values
	 *
	 * @default - None
	 */
	readonly lookupRoleArn?: string;
}
declare enum LoadBalancerListenerProtocol {
	/**
	 * HTTP protocol
	 */
	HTTP = "HTTP",
	/**
	 * HTTPS protocol
	 */
	HTTPS = "HTTPS",
	/**
	 * TCP protocol
	 */
	TCP = "TCP",
	/**
	 * TLS protocol
	 */
	TLS = "TLS",
	/**
	 * UDP protocol
	 * */
	UDP = "UDP",
	/**
	 * TCP and UDP protocol
	 * */
	TCP_UDP = "TCP_UDP"
}
/**
 * Query input for looking up a load balancer listener
 */
export interface LoadBalancerListenerContextQuery extends LoadBalancerFilter {
	/**
	 * Query account
	 */
	readonly account: string;
	/**
	 * Query region
	 */
	readonly region: string;
	/**
	 * The ARN of the role that should be used to look up the missing values
	 *
	 * @default - None
	 */
	readonly lookupRoleArn?: string;
	/**
	 * Find by listener's arn
	 * @default - does not find by listener arn
	 */
	readonly listenerArn?: string;
	/**
	 * Filter by listener protocol
	 * @default - does not filter by listener protocol
	 */
	readonly listenerProtocol?: LoadBalancerListenerProtocol;
	/**
	 * Filter listeners by listener port
	 * @default - does not filter by a listener port
	 */
	readonly listenerPort?: number;
}
/**
 * Query input for looking up a security group
 */
export interface SecurityGroupContextQuery {
	/**
	 * Query account
	 */
	readonly account: string;
	/**
	 * Query region
	 */
	readonly region: string;
	/**
	 * The ARN of the role that should be used to look up the missing values
	 *
	 * @default - None
	 */
	readonly lookupRoleArn?: string;
	/**
	 * Security group id
	 *
	 * @default - None
	 */
	readonly securityGroupId?: string;
	/**
	 * Security group name
	 *
	 * @default - None
	 */
	readonly securityGroupName?: string;
	/**
	 * VPC ID
	 *
	 * @default - None
	 */
	readonly vpcId?: string;
}
/**
 * Query input for looking up a KMS Key
 */
export interface KeyContextQuery {
	/**
	 * Query account
	 */
	readonly account: string;
	/**
	 * Query region
	 */
	readonly region: string;
	/**
	 * The ARN of the role that should be used to look up the missing values
	 *
	 * @default - None
	 */
	readonly lookupRoleArn?: string;
	/**
	 * Alias name used to search the Key
	 */
	readonly aliasName: string;
}
/**
 * Query input for plugins
 *
 * This alternate branch is necessary because it needs to be able to escape all type checking
 * we do on on the cloud assembly -- we cannot know the properties that will be used a priori.
 */
export interface PluginContextQuery {
	/**
	 * The name of the plugin
	 */
	readonly pluginName: string;
	/**
	 * Arbitrary other arguments for the plugin
	 */
	[key: string]: any;
}
export declare type ContextQueryProperties = AmiContextQuery | AvailabilityZonesContextQuery | HostedZoneContextQuery | SSMParameterContextQuery | VpcContextQuery | EndpointServiceAvailabilityZonesContextQuery | LoadBalancerContextQuery | LoadBalancerListenerContextQuery | SecurityGroupContextQuery | KeyContextQuery | PluginContextQuery;
declare enum ArtifactType {
	/**
	 * Stub required because of JSII.
	 */
	NONE = "none",
	/**
	 * The artifact is an AWS CloudFormation stack.
	 */
	AWS_CLOUDFORMATION_STACK = "aws:cloudformation:stack",
	/**
	 * The artifact contains the CDK application's construct tree.
	 */
	CDK_TREE = "cdk:tree",
	/**
	 * Manifest for all assets in the Cloud Assembly
	 */
	ASSET_MANIFEST = "cdk:asset-manifest",
	/**
	 * Nested Cloud Assembly
	 */
	NESTED_CLOUD_ASSEMBLY = "cdk:cloud-assembly"
}
/**
 * Information about the application's runtime components.
 */
export interface RuntimeInfo {
	/**
	 * The list of libraries loaded in the application, associated with their versions.
	 */
	readonly libraries: {
		[name: string]: string;
	};
}
/**
 * Represents a missing piece of context.
 */
export interface MissingContext {
	/**
	 * The missing context key.
	 */
	readonly key: string;
	/**
	 * The provider from which we expect this context key to be obtained.
	 */
	readonly provider: ContextProvider;
	/**
	 * A set of provider-specific options.
	 */
	readonly props: ContextQueryProperties;
}
/**
 * A manifest for a single artifact within the cloud assembly.
 */
export interface ArtifactManifest {
	/**
	 * The type of artifact.
	 */
	readonly type: ArtifactType;
	/**
	 * The environment into which this artifact is deployed.
	 *
	 * @default - no envrionment.
	 */
	readonly environment?: string;
	/**
	 * Associated metadata.
	 *
	 * @default - no metadata.
	 */
	readonly metadata?: {
		[path: string]: MetadataEntry[];
	};
	/**
	 * IDs of artifacts that must be deployed before this artifact.
	 *
	 * @default - no dependencies.
	 */
	readonly dependencies?: string[];
	/**
	 * The set of properties for this artifact (depends on type)
	 *
	 * @default - no properties.
	 */
	readonly properties?: ArtifactProperties;
	/**
	 * A string that represents this artifact. Should only be used in user interfaces.
	 *
	 * @default - no display name
	 */
	readonly displayName?: string;
}
/**
 * A manifest which describes the cloud assembly.
 */
export interface AssemblyManifest {
	/**
	 * Protocol version
	 */
	readonly version: string;
	/**
	 * The set of artifacts in this assembly.
	 *
	 * @default - no artifacts.
	 */
	readonly artifacts?: {
		[id: string]: ArtifactManifest;
	};
	/**
	 * Missing context information. If this field has values, it means that the
	 * cloud assembly is not complete and should not be deployed.
	 *
	 * @default - no missing context.
	 */
	readonly missing?: MissingContext[];
	/**
	 * Runtime information.
	 *
	 * @default - no info.
	 */
	readonly runtime?: RuntimeInfo;
}
/**
 * Options for the loadManifest operation
 */
export interface LoadManifestOptions {
	/**
	 * Skip the version check
	 *
	 * This means you may read a newer cloud assembly than the CX API is designed
	 * to support, and your application may not be aware of all features that in use
	 * in the Cloud Assembly.
	 *
	 * @default false
	 */
	readonly skipVersionCheck?: boolean;
	/**
	 * Skip enum checks
	 *
	 * This means you may read enum values you don't know about yet. Make sure to always
	 * check the values of enums you encounter in the manifest.
	 *
	 * @default false
	 */
	readonly skipEnumCheck?: boolean;
}
/**
 * Models an AWS execution environment, for use within the CDK toolkit.
 */
export interface Environment {
	/** The arbitrary name of this environment (user-set, or at least user-meaningful) */
	readonly name: string;
	/** The AWS account this environment deploys into */
	readonly account: string;
	/** The AWS region name where this environment deploys into */
	readonly region: string;
}
declare class CloudFormationStackArtifact extends CloudArtifact {
	/**
	 * The file name of the template.
	 */
	readonly templateFile: string;
	/**
	 * The original name as defined in the CDK app.
	 */
	readonly originalName: string;
	/**
	 * Any assets associated with this stack.
	 */
	readonly assets: cxschema.AssetMetadataEntry[];
	/**
	 * CloudFormation parameters to pass to the stack.
	 */
	readonly parameters: {
		[id: string]: string;
	};
	/**
	 * CloudFormation tags to pass to the stack.
	 */
	readonly tags: {
		[id: string]: string;
	};
	/**
	 * The physical name of this stack.
	 */
	readonly stackName: string;
	/**
	 * A string that represents this stack. Should only be used in user
	 * interfaces. If the stackName has not been set explicitly, or has been set
	 * to artifactId, it will return the hierarchicalId of the stack. Otherwise,
	 * it will return something like "<hierarchicalId> (<stackName>)"
	 */
	readonly displayName: string;
	/**
	 * The environment into which to deploy this artifact.
	 */
	readonly environment: Environment;
	/**
	 * The role that needs to be assumed to deploy the stack
	 *
	 * @default - No role is assumed (current credentials are used)
	 */
	readonly assumeRoleArn?: string;
	/**
	 * External ID to use when assuming role for cloudformation deployments
	 *
	 * @default - No external ID
	 */
	readonly assumeRoleExternalId?: string;
	/**
	 * The role that is passed to CloudFormation to execute the change set
	 *
	 * @default - No role is passed (currently assumed role/credentials are used)
	 */
	readonly cloudFormationExecutionRoleArn?: string;
	/**
	 * The role to use to look up values from the target AWS account
	 *
	 * @default - No role is assumed (current credentials are used)
	 */
	readonly lookupRole?: cxschema.BootstrapRole;
	/**
	 * If the stack template has already been included in the asset manifest, its asset URL
	 *
	 * @default - Not uploaded yet, upload just before deploying
	 */
	readonly stackTemplateAssetObjectUrl?: string;
	/**
	 * Version of bootstrap stack required to deploy this stack
	 *
	 * @default - No bootstrap stack required
	 */
	readonly requiresBootstrapStackVersion?: number;
	/**
	 * Name of SSM parameter with bootstrap stack version
	 *
	 * @default - Discover SSM parameter by reading stack
	 */
	readonly bootstrapStackVersionSsmParameter?: string;
	/**
	 * Whether termination protection is enabled for this stack.
	 */
	readonly terminationProtection?: boolean;
	/**
	 * Whether this stack should be validated by the CLI after synthesis
	 *
	 * @default - false
	 */
	readonly validateOnSynth?: boolean;
	private _template;
	constructor(assembly: CloudAssembly, artifactId: string, artifact: cxschema.ArtifactManifest);
	/**
	 * Full path to the template file
	 */
	get templateFullPath(): string;
	/**
	 * The CloudFormation template for this stack.
	 */
	get template(): any;
	private tagsFromMetadata;
}
declare class NestedCloudAssemblyArtifact extends CloudArtifact {
	/**
	 * The relative directory name of the asset manifest
	 */
	readonly directoryName: string;
	/**
	 * Display name
	 */
	readonly displayName: string;
	constructor(assembly: CloudAssembly, name: string, artifact: cxschema.ArtifactManifest);
	/**
	 * Full path to the nested assembly directory
	 */
	get fullPath(): string;
}
export interface NestedCloudAssemblyArtifact {
	/**
	 * The nested Assembly
	 */
	readonly nestedAssembly: CloudAssembly;
}
declare class TreeCloudArtifact extends CloudArtifact {
	readonly file: string;
	constructor(assembly: CloudAssembly, name: string, artifact: cxschema.ArtifactManifest);
}
declare class CloudAssembly {
	/**
	 * The root directory of the cloud assembly.
	 */
	readonly directory: string;
	/**
	 * The schema version of the assembly manifest.
	 */
	readonly version: string;
	/**
	 * All artifacts included in this assembly.
	 */
	readonly artifacts: CloudArtifact[];
	/**
	 * Runtime information such as module versions used to synthesize this assembly.
	 */
	readonly runtime: cxschema.RuntimeInfo;
	/**
	 * The raw assembly manifest.
	 */
	readonly manifest: cxschema.AssemblyManifest;
	/**
	 * Reads a cloud assembly from the specified directory.
	 * @param directory The root directory of the assembly.
	 */
	constructor(directory: string, loadOptions?: LoadManifestOptions);
	/**
	 * Attempts to find an artifact with a specific identity.
	 * @returns A `CloudArtifact` object or `undefined` if the artifact does not exist in this assembly.
	 * @param id The artifact ID
	 */
	tryGetArtifact(id: string): CloudArtifact | undefined;
	/**
	 * Returns a CloudFormation stack artifact from this assembly.
	 *
	 * Will only search the current assembly.
	 *
	 * @param stackName the name of the CloudFormation stack.
	 * @throws if there is no stack artifact by that name
	 * @throws if there is more than one stack with the same stack name. You can
	 * use `getStackArtifact(stack.artifactId)` instead.
	 * @returns a `CloudFormationStackArtifact` object.
	 */
	getStackByName(stackName: string): CloudFormationStackArtifact;
	/**
	 * Returns a CloudFormation stack artifact from this assembly.
	 *
	 * @param artifactId the artifact id of the stack (can be obtained through `stack.artifactId`).
	 * @throws if there is no stack artifact with that id
	 * @returns a `CloudFormationStackArtifact` object.
	 */
	getStackArtifact(artifactId: string): CloudFormationStackArtifact;
	private tryGetArtifactRecursively;
	/**
	 * Returns all the stacks, including the ones in nested assemblies
	 */
	get stacksRecursively(): CloudFormationStackArtifact[];
	/**
	 * Returns a nested assembly artifact.
	 *
	 * @param artifactId The artifact ID of the nested assembly
	 */
	getNestedAssemblyArtifact(artifactId: string): NestedCloudAssemblyArtifact;
	/**
	 * Returns a nested assembly.
	 *
	 * @param artifactId The artifact ID of the nested assembly
	 */
	getNestedAssembly(artifactId: string): CloudAssembly;
	/**
	 * Returns the tree metadata artifact from this assembly.
	 * @throws if there is no metadata artifact by that name
	 * @returns a `TreeCloudArtifact` object if there is one defined in the manifest, `undefined` otherwise.
	 */
	tree(): TreeCloudArtifact | undefined;
	/**
	 * @returns all the CloudFormation stack artifacts that are included in this assembly.
	 */
	get stacks(): CloudFormationStackArtifact[];
	/**
	 * The nested assembly artifacts in this assembly
	 */
	get nestedAssemblies(): NestedCloudAssemblyArtifact[];
	private validateDeps;
	private renderArtifacts;
}
/**
 * Construction properties for CloudAssemblyBuilder
 */
export interface CloudAssemblyBuilderProps {
	/**
	 * Use the given asset output directory
	 *
	 * @default - Same as the manifest outdir
	 */
	readonly assetOutdir?: string;
	/**
	 * If this builder is for a nested assembly, the parent assembly builder
	 *
	 * @default - This is a root assembly
	 */
	readonly parentBuilder?: CloudAssemblyBuilder;
}
declare class CloudAssemblyBuilder {
	/**
	 * The root directory of the resulting cloud assembly.
	 */
	readonly outdir: string;
	/**
	 * The directory where assets of this Cloud Assembly should be stored
	 */
	readonly assetOutdir: string;
	private readonly artifacts;
	private readonly missing;
	private readonly parentBuilder?;
	/**
	 * Initializes a cloud assembly builder.
	 * @param outdir The output directory, uses temporary directory if undefined
	 */
	constructor(outdir?: string, props?: CloudAssemblyBuilderProps);
	/**
	 * Adds an artifact into the cloud assembly.
	 * @param id The ID of the artifact.
	 * @param manifest The artifact manifest
	 */
	addArtifact(id: string, manifest: cxschema.ArtifactManifest): void;
	/**
	 * Reports that some context is missing in order for this cloud assembly to be fully synthesized.
	 * @param missing Missing context information.
	 */
	addMissing(missing: cxschema.MissingContext): void;
	/**
	 * Finalizes the cloud assembly into the output directory returns a
	 * `CloudAssembly` object that can be used to inspect the assembly.
	 * @param options
	 */
	buildAssembly(options?: AssemblyBuildOptions): CloudAssembly;
	/**
	 * Creates a nested cloud assembly
	 */
	createNestedAssembly(artifactId: string, displayName: string): CloudAssemblyBuilder;
}
export interface AssemblyBuildOptions {
}
declare enum SynthesisMessageLevel {
	INFO = "info",
	WARNING = "warning",
	ERROR = "error"
}
export interface MetadataEntryResult extends cxschema.MetadataEntry {
	/**
	 * The path in which this entry was defined.
	 */
	readonly path: string;
}
export interface SynthesisMessage {
	readonly level: SynthesisMessageLevel;
	readonly id: string;
	readonly entry: cxschema.MetadataEntry;
}
declare class CloudArtifact {
	readonly assembly: CloudAssembly;
	readonly id: string;
	/**
	 * Returns a subclass of `CloudArtifact` based on the artifact type defined in the artifact manifest.
	 *
	 * @param assembly The cloud assembly from which to load the artifact
	 * @param id The artifact ID
	 * @param artifact The artifact manifest
	 * @returns the `CloudArtifact` that matches the artifact type or `undefined` if it's an artifact type that is unrecognized by this module.
	 */
	static fromManifest(assembly: CloudAssembly, id: string, artifact: cxschema.ArtifactManifest): CloudArtifact | undefined;
	/**
	 * The artifact's manifest
	 */
	readonly manifest: cxschema.ArtifactManifest;
	/**
	 * The set of messages extracted from the artifact's metadata.
	 */
	readonly messages: SynthesisMessage[];
	/**
	 * IDs of all dependencies. Used when topologically sorting the artifacts within the cloud assembly.
	 * @internal
	 */
	readonly _dependencyIDs: string[];
	/**
	 * Cache of resolved dependencies.
	 */
	private _deps?;
	protected constructor(assembly: CloudAssembly, id: string, manifest: cxschema.ArtifactManifest);
	/**
	 * Returns all the artifacts that this artifact depends on.
	 */
	get dependencies(): CloudArtifact[];
	/**
	 * @returns all the metadata entries of a specific type in this artifact.
	 * @param type
	 */
	findMetadataByType(type: string): MetadataEntryResult[];
	private renderMessages;
	/**
	 * An identifier that shows where this artifact is located in the tree
	 * of nested assemblies, based on their manifests. Defaults to the normal
	 * id. Should only be used in user interfaces.
	 */
	get hierarchicalId(): string;
}
declare enum ArnFormat {
	/**
	 * This represents a format where there is no 'resourceName' part.
	 * This format is used for S3 resources,
	 * like 'arn:aws:s3:::bucket'.
	 * Everything after the last colon is considered the 'resource',
	 * even if it contains slashes,
	 * like in 'arn:aws:s3:::bucket/object.zip'.
	 */
	NO_RESOURCE_NAME = "arn:aws:service:region:account:resource",
	/**
	 * This represents a format where the 'resource' and 'resourceName'
	 * parts are separated with a colon.
	 * Like in: 'arn:aws:service:region:account:resource:resourceName'.
	 * Everything after the last colon is considered the 'resourceName',
	 * even if it contains slashes,
	 * like in 'arn:aws:apigateway:region:account:resource:/test/mydemoresource/*'.
	 */
	COLON_RESOURCE_NAME = "arn:aws:service:region:account:resource:resourceName",
	/**
	 * This represents a format where the 'resource' and 'resourceName'
	 * parts are separated with a slash.
	 * Like in: 'arn:aws:service:region:account:resource/resourceName'.
	 * Everything after the separating slash is considered the 'resourceName',
	 * even if it contains colons,
	 * like in 'arn:aws:cognito-sync:region:account:identitypool/us-east-1:1a1a1a1a-ffff-1111-9999-12345678:bla'.
	 */
	SLASH_RESOURCE_NAME = "arn:aws:service:region:account:resource/resourceName",
	/**
	 * This represents a format where the 'resource' and 'resourceName'
	 * parts are seperated with a slash,
	 * but there is also an additional slash after the colon separating 'account' from 'resource'.
	 * Like in: 'arn:aws:service:region:account:/resource/resourceName'.
	 * Note that the leading slash is _not_ included in the parsed 'resource' part.
	 */
	SLASH_RESOURCE_SLASH_RESOURCE_NAME = "arn:aws:service:region:account:/resource/resourceName"
}
export interface ArnComponents {
	/**
	 * The partition that the resource is in. For standard AWS regions, the
	 * partition is aws. If you have resources in other partitions, the
	 * partition is aws-partitionname. For example, the partition for resources
	 * in the China (Beijing) region is aws-cn.
	 *
	 * @default The AWS partition the stack is deployed to.
	 */
	readonly partition?: string;
	/**
	 * The service namespace that identifies the AWS product (for example,
	 * 's3', 'iam', 'codepipline').
	 */
	readonly service: string;
	/**
	 * The region the resource resides in. Note that the ARNs for some resources
	 * do not require a region, so this component might be omitted.
	 *
	 * @default The region the stack is deployed to.
	 */
	readonly region?: string;
	/**
	 * The ID of the AWS account that owns the resource, without the hyphens.
	 * For example, 123456789012. Note that the ARNs for some resources don't
	 * require an account number, so this component might be omitted.
	 *
	 * @default The account the stack is deployed to.
	 */
	readonly account?: string;
	/**
	 * Resource type (e.g. "table", "autoScalingGroup", "certificate").
	 * For some resource types, e.g. S3 buckets, this field defines the bucket name.
	 */
	readonly resource: string;
	/**
	 * Resource name or path within the resource (i.e. S3 bucket object key) or
	 * a wildcard such as ``"*"``. This is service-dependent.
	 */
	readonly resourceName?: string;
	/**
	 * The specific ARN format to use for this ARN value.
	 *
	 * @default - uses value of `sep` as the separator for formatting,
	 *   `ArnFormat.SLASH_RESOURCE_NAME` if that property was also not provided
	 */
	readonly arnFormat?: ArnFormat;
}
/**
 * Represents the source for a file asset.
 */
export interface FileAssetSource {
	/**
	 * A hash on the content source. This hash is used to uniquely identify this
	 * asset throughout the system. If this value doesn't change, the asset will
	 * not be rebuilt or republished.
	 */
	readonly sourceHash: string;
	/**
	 * An external command that will produce the packaged asset.
	 *
	 * The command should produce the location of a ZIP file on `stdout`.
	 *
	 * @default - Exactly one of `directory` and `executable` is required
	 */
	readonly executable?: string[];
	/**
	 * The path, relative to the root of the cloud assembly, in which this asset
	 * source resides. This can be a path to a file or a directory, depending on the
	 * packaging type.
	 *
	 * @default - Exactly one of `directory` and `executable` is required
	 */
	readonly fileName?: string;
	/**
	 * Which type of packaging to perform.
	 *
	 * @default - Required if `fileName` is specified.
	 */
	readonly packaging?: FileAssetPackaging;
}
export interface DockerImageAssetSource {
	/**
	 * The hash of the contents of the docker build context. This hash is used
	 * throughout the system to identify this image and avoid duplicate work
	 * in case the source did not change.
	 *
	 * NOTE: this means that if you wish to update your docker image, you
	 * must make a modification to the source (e.g. add some metadata to your Dockerfile).
	 */
	readonly sourceHash: string;
	/**
	 * An external command that will produce the packaged asset.
	 *
	 * The command should produce the name of a local Docker image on `stdout`.
	 *
	 * @default - Exactly one of `directoryName` and `executable` is required
	 */
	readonly executable?: string[];
	/**
	 * The directory where the Dockerfile is stored, must be relative
	 * to the cloud assembly root.
	 *
	 * @default - Exactly one of `directoryName` and `executable` is required
	 */
	readonly directoryName?: string;
	/**
	 * Build args to pass to the `docker build` command.
	 *
	 * Since Docker build arguments are resolved before deployment, keys and
	 * values cannot refer to unresolved tokens (such as `lambda.functionArn` or
	 * `queue.queueUrl`).
	 *
	 * Only allowed when `directoryName` is specified.
	 *
	 * @default - no build args are passed
	 */
	readonly dockerBuildArgs?: {
		[key: string]: string;
	};
	/**
	 * Docker target to build to
	 *
	 * Only allowed when `directoryName` is specified.
	 *
	 * @default - no target
	 */
	readonly dockerBuildTarget?: string;
	/**
	 * Path to the Dockerfile (relative to the directory).
	 *
	 * Only allowed when `directoryName` is specified.
	 *
	 * @default - no file
	 */
	readonly dockerFile?: string;
	/**
	 * Networking mode for the RUN commands during build. _Requires Docker Engine API v1.25+_.
	 *
	 * Specify this property to build images on a specific networking mode.
	 *
	 * @default - no networking mode specified
	 */
	readonly networkMode?: string;
	/**
	 * Platform to build for. _Requires Docker Buildx_.
	 *
	 * Specify this property to build images on a specific platform.
	 *
	 * @default - no platform specified (the current machine architecture will be used)
	 */
	readonly platform?: string;
}
declare enum FileAssetPackaging {
	/**
	 * The asset source path points to a directory, which should be archived using
	 * zip and and then uploaded to Amazon S3.
	 */
	ZIP_DIRECTORY = "zip",
	/**
	 * The asset source path points to a single file, which should be uploaded
	 * to Amazon S3.
	 */
	FILE = "file"
}
/**
 * The location of the published file asset. This is where the asset
 * can be consumed at runtime.
 */
export interface FileAssetLocation {
	/**
	 * The name of the Amazon S3 bucket.
	 */
	readonly bucketName: string;
	/**
	 * The Amazon S3 object key.
	 */
	readonly objectKey: string;
	/**
	 * The HTTP URL of this asset on Amazon S3.
	 *
	 * This value suitable for inclusion in a CloudFormation template, and
	 * may be an encoded token.
	 *
	 * Example value: `https://s3-us-east-1.amazonaws.com/mybucket/myobject`
	 */
	readonly httpUrl: string;
	/**
	 * The S3 URL of this asset on Amazon S3.
	 *
	 * This value suitable for inclusion in a CloudFormation template, and
	 * may be an encoded token.
	 *
	 * Example value: `s3://mybucket/myobject`
	 */
	readonly s3ObjectUrl: string;
	/**
	 * The ARN of the KMS key used to encrypt the file asset bucket, if any.
	 *
	 * The CDK bootstrap stack comes with a key policy that does not require
	 * setting this property, so you only need to set this property if you
	 * have customized the bootstrap stack to require it.
	 *
	 * @default - Asset bucket is not encrypted, or decryption permissions are
	 * defined by a Key Policy.
	 */
	readonly kmsKeyArn?: string;
	/**
	 * Like `s3ObjectUrl`, but not suitable for CloudFormation consumption
	 *
	 * If there are placeholders in the S3 URL, they will be returned unreplaced
	 * and un-evaluated.
	 *
	 * @default - This feature cannot be used
	 */
	readonly s3ObjectUrlWithPlaceholders?: string;
}
/**
 * The location of the published docker image. This is where the image can be
 * consumed at runtime.
 */
export interface DockerImageAssetLocation {
	/**
	 * The URI of the image in Amazon ECR (including a tag).
	 */
	readonly imageUri: string;
	/**
	 * The name of the ECR repository.
	 */
	readonly repositoryName: string;
	/**
	 * The tag of the image in Amazon ECR.
	 * @default - the hash of the asset, or the `dockerTagPrefix` concatenated with the asset hash if a `dockerTagPrefix` is specified in the stack synthesizer
	 */
	readonly imageTag?: string;
}
/**
 * The deployment environment for a stack.
 */
export interface Environment {
	/**
	 * The AWS account ID for this environment.
	 *
	 * This can be either a concrete value such as `585191031104` or `Aws.ACCOUNT_ID` which
	 * indicates that account ID will only be determined during deployment (it
	 * will resolve to the CloudFormation intrinsic `{"Ref":"AWS::AccountId"}`).
	 * Note that certain features, such as cross-stack references and
	 * environmental context providers require concerete region information and
	 * will cause this stack to emit synthesis errors.
	 *
	 * @default Aws.ACCOUNT_ID which means that the stack will be account-agnostic.
	 */
	readonly account?: string;
	/**
	 * The AWS region for this environment.
	 *
	 * This can be either a concrete value such as `eu-west-2` or `Aws.REGION`
	 * which indicates that account ID will only be determined during deployment
	 * (it will resolve to the CloudFormation intrinsic `{"Ref":"AWS::Region"}`).
	 * Note that certain features, such as cross-stack references and
	 * environmental context providers require concrete region information and
	 * will cause this stack to emit synthesis errors.
	 *
	 * @default Aws.REGION which means that the stack will be region-agnostic.
	 */
	readonly region?: string;
}
/**
 * Current resolution context for tokens
 */
export interface IResolveContext {
	/**
	 * The scope from which resolution has been initiated
	 */
	readonly scope: IConstruct;
	/**
	 * True when we are still preparing, false if we're rendering the final output
	 */
	readonly preparing: boolean;
	/**
	 * Path in the JSON document that is being constructed
	 */
	readonly documentPath: string[];
	/**
	 * Resolve an inner object
	 */
	resolve(x: any, options?: ResolveChangeContextOptions): any;
	/**
	 * Use this postprocessor after the entire token structure has been resolved
	 */
	registerPostProcessor(postProcessor: IPostProcessor): void;
}
/**
 * Options that can be changed while doing a recursive resolve
 */
export interface ResolveChangeContextOptions {
	/**
	 * Change the 'allowIntrinsicKeys' option
	 *
	 * @default - Unchanged
	 */
	readonly allowIntrinsicKeys?: boolean;
}
/**
 * Interface for values that can be resolvable later
 *
 * Tokens are special objects that participate in synthesis.
 */
export interface IResolvable {
	/**
	 * The creation stack of this resolvable which will be appended to errors
	 * thrown during resolution.
	 *
	 * This may return an array with a single informational element indicating how
	 * to get this property populated, if it was skipped for performance reasons.
	 */
	readonly creationStack: string[];
	/**
	 * Produce the Token's value at resolution time
	 */
	resolve(context: IResolveContext): any;
	/**
	 * Return a string representation of this resolvable object.
	 *
	 * Returns a reversible string representation.
	 */
	toString(): string;
}
/**
 * A Token that can post-process the complete resolved value, after resolve() has recursed over it
 */
export interface IPostProcessor {
	/**
	 * Process the completely resolved value, after full recursion/resolution has happened
	 */
	postProcess(input: any, context: IResolveContext): any;
}
/**
 * Customization properties for an Intrinsic token
 *
 */
export interface IntrinsicProps {
	/**
	 * Capture the stack trace of where this token is created
	 *
	 * @default true
	 */
	readonly stackTrace?: boolean;
}
declare class Intrinsic implements IResolvable {
	/**
	 * The captured stack trace which represents the location in which this token was created.
	 */
	readonly creationStack: string[];
	private readonly value;
	constructor(value: any, options?: IntrinsicProps);
	resolve(_context: IResolveContext): any;
	/**
	 * Convert an instance of this Token to a string
	 *
	 * This method will be called implicitly by language runtimes if the object
	 * is embedded into a string. We treat it the same as an explicit
	 * stringification.
	 */
	toString(): string;
	/**
	 * Convert an instance of this Token to a string list
	 *
	 * This method will be called implicitly by language runtimes if the object
	 * is embedded into a list. We treat it the same as an explicit
	 * stringification.
	 */
	toStringList(): string[];
	/**
	 * Turn this Token into JSON
	 *
	 * Called automatically when JSON.stringify() is called on a Token.
	 */
	toJSON(): any;
	/**
	 * Creates a throwable Error object that contains the token creation stack trace.
	 * @param message Error message
	 */
	protected newError(message: string): any;
}
declare abstract class Reference extends Intrinsic {
	/**
	 * Check whether this is actually a Reference
	 */
	static isReference(x: any): x is Reference;
	readonly target: IConstruct;
	readonly displayName: string;
	constructor(value: any, target: IConstruct, displayName?: string);
}
/**
 * Encodes information how a certain Stack should be deployed
 */
export interface IStackSynthesizer {
	/**
	 * Bind to the stack this environment is going to be used on
	 *
	 * Must be called before any of the other methods are called.
	 */
	bind(stack: Stack): void;
	/**
	 * Register a File Asset
	 *
	 * Returns the parameters that can be used to refer to the asset inside the template.
	 */
	addFileAsset(asset: FileAssetSource): FileAssetLocation;
	/**
	 * Register a Docker Image Asset
	 *
	 * Returns the parameters that can be used to refer to the asset inside the template.
	 */
	addDockerImageAsset(asset: DockerImageAssetSource): DockerImageAssetLocation;
	/**
	 * Synthesize the associated stack to the session
	 */
	synthesize(session: ISynthesisSession): void;
}
/**
 * Represents a single session of synthesis. Passed into `Construct.synthesize()` methods.
 */
export interface ISynthesisSession {
	/**
	 * The output directory for this synthesis session.
	 */
	outdir: string;
	/**
	 * Cloud assembly builder.
	 */
	assembly: CloudAssemblyBuilder;
	/**
	* Whether the stack should be validated after synthesis to check for error metadata
	*
	* @default - false
	*/
	validateOnSynth?: boolean;
}
export interface StackProps {
	/**
	 * A description of the stack.
	 *
	 * @default - No description.
	 */
	readonly description?: string;
	/**
	 * The AWS environment (account/region) where this stack will be deployed.
	 *
	 * Set the `region`/`account` fields of `env` to either a concrete value to
	 * select the indicated environment (recommended for production stacks), or to
	 * the values of environment variables
	 * `CDK_DEFAULT_REGION`/`CDK_DEFAULT_ACCOUNT` to let the target environment
	 * depend on the AWS credentials/configuration that the CDK CLI is executed
	 * under (recommended for development stacks).
	 *
	 * If the `Stack` is instantiated inside a `Stage`, any undefined
	 * `region`/`account` fields from `env` will default to the same field on the
	 * encompassing `Stage`, if configured there.
	 *
	 * If either `region` or `account` are not set nor inherited from `Stage`, the
	 * Stack will be considered "*environment-agnostic*"". Environment-agnostic
	 * stacks can be deployed to any environment but may not be able to take
	 * advantage of all features of the CDK. For example, they will not be able to
	 * use environmental context lookups such as `ec2.Vpc.fromLookup` and will not
	 * automatically translate Service Principals to the right format based on the
	 * environment's AWS partition, and other such enhancements.
	 *
	 * @example
	 *
	 * // Use a concrete account and region to deploy this stack to:
	 * // `.account` and `.region` will simply return these values.
	 * new Stack(app, 'Stack1', {
	 *   env: {
	 *     account: '123456789012',
	 *     region: 'us-east-1'
	 *   },
	 * });
	 *
	 * // Use the CLI's current credentials to determine the target environment:
	 * // `.account` and `.region` will reflect the account+region the CLI
	 * // is configured to use (based on the user CLI credentials)
	 * new Stack(app, 'Stack2', {
	 *   env: {
	 *     account: process.env.CDK_DEFAULT_ACCOUNT,
	 *     region: process.env.CDK_DEFAULT_REGION
	 *   },
	 * });
	 *
	 * // Define multiple stacks stage associated with an environment
	 * const myStage = new Stage(app, 'MyStage', {
	 *   env: {
	 *     account: '123456789012',
	 *     region: 'us-east-1'
	 *   }
	 * });
	 *
	 * // both of these stacks will use the stage's account/region:
	 * // `.account` and `.region` will resolve to the concrete values as above
	 * new MyStack(myStage, 'Stack1');
	 * new YourStack(myStage, 'Stack2');
	 *
	 * // Define an environment-agnostic stack:
	 * // `.account` and `.region` will resolve to `{ "Ref": "AWS::AccountId" }` and `{ "Ref": "AWS::Region" }` respectively.
	 * // which will only resolve to actual values by CloudFormation during deployment.
	 * new MyStack(app, 'Stack1');
	 *
	 * @default - The environment of the containing `Stage` if available,
	 * otherwise create the stack will be environment-agnostic.
	 */
	readonly env?: Environment;
	/**
	 * Name to deploy the stack with
	 *
	 * @default - Derived from construct path.
	 */
	readonly stackName?: string;
	/**
	 * Stack tags that will be applied to all the taggable resources and the stack itself.
	 *
	 * @default {}
	 */
	readonly tags?: {
		[key: string]: string;
	};
	/**
	 * Synthesis method to use while deploying this stack
	 *
	 * @default - `DefaultStackSynthesizer` if the `@aws-cdk/core:newStyleStackSynthesis` feature flag
	 * is set, `LegacyStackSynthesizer` otherwise.
	 */
	readonly synthesizer?: IStackSynthesizer;
	/**
	 * Whether to enable termination protection for this stack.
	 *
	 * @default false
	 */
	readonly terminationProtection?: boolean;
	/**
	 * Include runtime versioning information in this Stack
	 *
	 * @default `analyticsReporting` setting of containing `App`, or value of
	 * 'aws:cdk:version-reporting' context key
	 */
	readonly analyticsReporting?: boolean;
}
declare class Stack extends Construct implements ITaggable {
	/**
	 * Return whether the given object is a Stack.
	 *
	 * We do attribute detection since we can't reliably use 'instanceof'.
	 */
	static isStack(x: any): x is Stack;
	/**
	 * Looks up the first stack scope in which `construct` is defined. Fails if there is no stack up the tree.
	 * @param construct The construct to start the search from.
	 */
	static of(construct: IConstruct): Stack;
	/**
	 * Tags to be applied to the stack.
	 */
	readonly tags: TagManager;
	/**
	 * Options for CloudFormation template (like version, transform, description).
	 */
	readonly templateOptions: ITemplateOptions;
	/**
	 * The AWS region into which this stack will be deployed (e.g. `us-west-2`).
	 *
	 * This value is resolved according to the following rules:
	 *
	 * 1. The value provided to `env.region` when the stack is defined. This can
	 *    either be a concerete region (e.g. `us-west-2`) or the `Aws.REGION`
	 *    token.
	 * 3. `Aws.REGION`, which is represents the CloudFormation intrinsic reference
	 *    `{ "Ref": "AWS::Region" }` encoded as a string token.
	 *
	 * Preferably, you should use the return value as an opaque string and not
	 * attempt to parse it to implement your logic. If you do, you must first
	 * check that it is a concerete value an not an unresolved token. If this
	 * value is an unresolved token (`Token.isUnresolved(stack.region)` returns
	 * `true`), this implies that the user wishes that this stack will synthesize
	 * into a **region-agnostic template**. In this case, your code should either
	 * fail (throw an error, emit a synth error using `Annotations.of(construct).addError()`) or
	 * implement some other region-agnostic behavior.
	 */
	readonly region: string;
	/**
	 * The AWS account into which this stack will be deployed.
	 *
	 * This value is resolved according to the following rules:
	 *
	 * 1. The value provided to `env.account` when the stack is defined. This can
	 *    either be a concrete account (e.g. `585695031111`) or the
	 *    `Aws.ACCOUNT_ID` token.
	 * 3. `Aws.ACCOUNT_ID`, which represents the CloudFormation intrinsic reference
	 *    `{ "Ref": "AWS::AccountId" }` encoded as a string token.
	 *
	 * Preferably, you should use the return value as an opaque string and not
	 * attempt to parse it to implement your logic. If you do, you must first
	 * check that it is a concerete value an not an unresolved token. If this
	 * value is an unresolved token (`Token.isUnresolved(stack.account)` returns
	 * `true`), this implies that the user wishes that this stack will synthesize
	 * into a **account-agnostic template**. In this case, your code should either
	 * fail (throw an error, emit a synth error using `Annotations.of(construct).addError()`) or
	 * implement some other region-agnostic behavior.
	 */
	readonly account: string;
	/**
	 * The environment coordinates in which this stack is deployed. In the form
	 * `aws://account/region`. Use `stack.account` and `stack.region` to obtain
	 * the specific values, no need to parse.
	 *
	 * You can use this value to determine if two stacks are targeting the same
	 * environment.
	 *
	 * If either `stack.account` or `stack.region` are not concrete values (e.g.
	 * `Aws.ACCOUNT_ID` or `Aws.REGION`) the special strings `unknown-account` and/or
	 * `unknown-region` will be used respectively to indicate this stack is
	 * region/account-agnostic.
	 */
	readonly environment: string;
	/**
	 * Whether termination protection is enabled for this stack.
	 */
	readonly terminationProtection?: boolean;
	/**
	 * If this is a nested stack, this represents its `AWS::CloudFormation::Stack`
	 * resource. `undefined` for top-level (non-nested) stacks.
	 *
	 */
	readonly nestedStackResource?: CfnResource;
	/**
	 * The name of the CloudFormation template file emitted to the output
	 * directory during synthesis.
	 *
	 * Example value: `MyStack.template.json`
	 */
	readonly templateFile: string;
	/**
	 * The ID of the cloud assembly artifact for this stack.
	 */
	readonly artifactId: string;
	/**
	 * Synthesis method for this stack
	 *
	 */
	readonly synthesizer: IStackSynthesizer;
	/**
	 * Whether version reporting is enabled for this stack
	 *
	 * Controls whether the CDK Metadata resource is injected
	 *
	 * @internal
	 */
	readonly _versionReportingEnabled: boolean;
	/**
	 * Logical ID generation strategy
	 */
	private readonly _logicalIds;
	/**
	 * Other stacks this stack depends on
	 */
	private readonly _stackDependencies;
	/**
	 * Lists all missing contextual information.
	 * This is returned when the stack is synthesized under the 'missing' attribute
	 * and allows tooling to obtain the context and re-synthesize.
	 */
	private readonly _missingContext;
	private readonly _stackName;
	/**
	 * Creates a new stack.
	 *
	 * @param scope Parent of this stack, usually an `App` or a `Stage`, but could be any construct.
	 * @param id The construct ID of this stack. If `stackName` is not explicitly
	 * defined, this id (and any parent IDs) will be used to determine the
	 * physical ID of the stack.
	 * @param props Stack properties.
	 */
	constructor(scope?: Construct, id?: string, props?: StackProps);
	/**
	 * Resolve a tokenized value in the context of the current stack.
	 */
	resolve(obj: any): any;
	/**
	 * Convert an object, potentially containing tokens, to a JSON string
	 */
	toJsonString(obj: any, space?: number): string;
	/**
	 * Indicate that a context key was expected
	 *
	 * Contains instructions which will be emitted into the cloud assembly on how
	 * the key should be supplied.
	 *
	 * @param report The set of parameters needed to obtain the context
	 */
	reportMissingContextKey(report: cxschema.MissingContext): void;
	/**
	 * Rename a generated logical identities
	 *
	 * To modify the naming scheme strategy, extend the `Stack` class and
	 * override the `allocateLogicalId` method.
	 */
	renameLogicalId(oldId: string, newId: string): void;
	/**
	 * Allocates a stack-unique CloudFormation-compatible logical identity for a
	 * specific resource.
	 *
	 * This method is called when a `CfnElement` is created and used to render the
	 * initial logical identity of resources. Logical ID renames are applied at
	 * this stage.
	 *
	 * This method uses the protected method `allocateLogicalId` to render the
	 * logical ID for an element. To modify the naming scheme, extend the `Stack`
	 * class and override this method.
	 *
	 * @param element The CloudFormation element for which a logical identity is
	 * needed.
	 */
	getLogicalId(element: CfnElement): string;
	/**
	 * Add a dependency between this stack and another stack.
	 *
	 * This can be used to define dependencies between any two stacks within an
	 * app, and also supports nested stacks.
	 */
	addDependency(target: Stack, reason?: string): void;
	/**
	 * Return the stacks this stack depends on
	 */
	get dependencies(): Stack[];
	/**
	 * The concrete CloudFormation physical stack name.
	 *
	 * This is either the name defined explicitly in the `stackName` prop or
	 * allocated based on the stack's location in the construct tree. Stacks that
	 * are directly defined under the app use their construct `id` as their stack
	 * name. Stacks that are defined deeper within the tree will use a hashed naming
	 * scheme based on the construct path to ensure uniqueness.
	 *
	 * If you wish to obtain the deploy-time AWS::StackName intrinsic,
	 * you can use `Aws.STACK_NAME` directly.
	 */
	get stackName(): string;
	/**
	 * The partition in which this stack is defined
	 */
	get partition(): string;
	/**
	 * The Amazon domain suffix for the region in which this stack is defined
	 */
	get urlSuffix(): string;
	/**
	 * The ID of the stack
	 *
	 * @example
	 * // After resolving, looks like
	 * 'arn:aws:cloudformation:us-west-2:123456789012:stack/teststack/51af3dc0-da77-11e4-872e-1234567db123'
	 */
	get stackId(): string;
	/**
	 * Returns the list of notification Amazon Resource Names (ARNs) for the current stack.
	 */
	get notificationArns(): string[];
	/**
	 * Indicates if this is a nested stack, in which case `parentStack` will include a reference to it's parent.
	 */
	get nested(): boolean;
	/**
	 * Creates an ARN from components.
	 *
	 * If `partition`, `region` or `account` are not specified, the stack's
	 * partition, region and account will be used.
	 *
	 * If any component is the empty string, an empty string will be inserted
	 * into the generated ARN at the location that component corresponds to.
	 *
	 * The ARN will be formatted as follows:
	 *
	 *   arn:{partition}:{service}:{region}:{account}:{resource}{sep}{resource-name}
	 *
	 * The required ARN pieces that are omitted will be taken from the stack that
	 * the 'scope' is attached to. If all ARN pieces are supplied, the supplied scope
	 * can be 'undefined'.
	 */
	formatArn(components: ArnComponents): string;
	/**
	 * Splits the provided ARN into its components.
	 * Works both if 'arn' is a string like 'arn:aws:s3:::bucket',
	 * and a Token representing a dynamic CloudFormation expression
	 * (in which case the returned components will also be dynamic CloudFormation expressions,
	 * encoded as Tokens).
	 *
	 * @param arn the ARN to split into its components
	 * @param arnFormat the expected format of 'arn' - depends on what format the service 'arn' represents uses
	 */
	splitArn(arn: string, arnFormat: ArnFormat): ArnComponents;
	/**
	 * Returns the list of AZs that are available in the AWS environment
	 * (account/region) associated with this stack.
	 *
	 * If the stack is environment-agnostic (either account and/or region are
	 * tokens), this property will return an array with 2 tokens that will resolve
	 * at deploy-time to the first two availability zones returned from CloudFormation's
	 * `Fn::GetAZs` intrinsic function.
	 *
	 * If they are not available in the context, returns a set of dummy values and
	 * reports them as missing, and let the CLI resolve them by calling EC2
	 * `DescribeAvailabilityZones` on the target environment.
	 *
	 * To specify a different strategy for selecting availability zones override this method.
	 */
	get availabilityZones(): string[];
	/**
	 * If this is a nested stack, returns it's parent stack.
	 */
	get nestedStackParent(): Stack | undefined;
	/**
	 * Add a Transform to this stack. A Transform is a macro that AWS
	 * CloudFormation uses to process your template.
	 *
	 * Duplicate values are removed when stack is synthesized.
	 *
	 * @see https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/transform-section-structure.html
	 * @param transform The transform to add
	 *
	 * @example
	 * declare const stack: Stack;
	 *
	 * stack.addTransform('AWS::Serverless-2016-10-31')
	 */
	addTransform(transform: string): void;
	/**
	 * Adds an arbitary key-value pair, with information you want to record about the stack.
	 * These get translated to the Metadata section of the generated template.
	 *
	 * @see https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html
	 */
	addMetadata(key: string, value: any): void;
	/**
	 * Called implicitly by the `addDependency` helper function in order to
	 * realize a dependency between two top-level stacks at the assembly level.
	 *
	 * Use `stack.addDependency` to define the dependency between any two stacks,
	 * and take into account nested stack relationships.
	 *
	 * @internal
	 */
	_addAssemblyDependency(target: Stack, reason?: string): void;
	/**
	 * Synthesizes the cloudformation template into a cloud assembly.
	 * @internal
	 */
	_synthesizeTemplate(session: ISynthesisSession, lookupRoleArn?: string): void;
	/**
	 * Look up a fact value for the given fact for the region of this stack
	 *
	 * Will return a definite value only if the region of the current stack is resolved.
	 * If not, a lookup map will be added to the stack and the lookup will be done at
	 * CDK deployment time.
	 *
	 * What regions will be included in the lookup map is controlled by the
	 * `@aws-cdk/core:target-partitions` context value: it must be set to a list
	 * of partitions, and only regions from the given partitions will be included.
	 * If no such context key is set, all regions will be included.
	 *
	 * This function is intended to be used by construct library authors. Application
	 * builders can rely on the abstractions offered by construct libraries and do
	 * not have to worry about regional facts.
	 *
	 * If `defaultValue` is not given, it is an error if the fact is unknown for
	 * the given region.
	 */
	regionalFact(factName: string, defaultValue?: string): string;
	/**
	 * Create a CloudFormation Export for a value
	 *
	 * Returns a string representing the corresponding `Fn.importValue()`
	 * expression for this Export. You can control the name for the export by
	 * passing the `name` option.
	 *
	 * If you don't supply a value for `name`, the value you're exporting must be
	 * a Resource attribute (for example: `bucket.bucketName`) and it will be
	 * given the same name as the automatic cross-stack reference that would be created
	 * if you used the attribute in another Stack.
	 *
	 * One of the uses for this method is to *remove* the relationship between
	 * two Stacks established by automatic cross-stack references. It will
	 * temporarily ensure that the CloudFormation Export still exists while you
	 * remove the reference from the consuming stack. After that, you can remove
	 * the resource and the manual export.
	 *
	 * ## Example
	 *
	 * Here is how the process works. Let's say there are two stacks,
	 * `producerStack` and `consumerStack`, and `producerStack` has a bucket
	 * called `bucket`, which is referenced by `consumerStack` (perhaps because
	 * an AWS Lambda Function writes into it, or something like that).
	 *
	 * It is not safe to remove `producerStack.bucket` because as the bucket is being
	 * deleted, `consumerStack` might still be using it.
	 *
	 * Instead, the process takes two deployments:
	 *
	 * ### Deployment 1: break the relationship
	 *
	 * - Make sure `consumerStack` no longer references `bucket.bucketName` (maybe the consumer
	 *   stack now uses its own bucket, or it writes to an AWS DynamoDB table, or maybe you just
	 *   remove the Lambda Function altogether).
	 * - In the `ProducerStack` class, call `this.exportValue(this.bucket.bucketName)`. This
	 *   will make sure the CloudFormation Export continues to exist while the relationship
	 *   between the two stacks is being broken.
	 * - Deploy (this will effectively only change the `consumerStack`, but it's safe to deploy both).
	 *
	 * ### Deployment 2: remove the bucket resource
	 *
	 * - You are now free to remove the `bucket` resource from `producerStack`.
	 * - Don't forget to remove the `exportValue()` call as well.
	 * - Deploy again (this time only the `producerStack` will be changed -- the bucket will be deleted).
	 */
	exportValue(exportedValue: any, options?: ExportValueOptions): string;
	/**
	 * Returns the naming scheme used to allocate logical IDs. By default, uses
	 * the `HashedAddressingScheme` but this method can be overridden to customize
	 * this behavior.
	 *
	 * In order to make sure logical IDs are unique and stable, we hash the resource
	 * construct tree path (i.e. toplevel/secondlevel/.../myresource) and add it as
	 * a suffix to the path components joined without a separator (CloudFormation
	 * IDs only allow alphanumeric characters).
	 *
	 * The result will be:
	 *
	 *   <path.join('')><md5(path.join('/')>
	 *     "human"      "hash"
	 *
	 * If the "human" part of the ID exceeds 240 characters, we simply trim it so
	 * the total ID doesn't exceed CloudFormation's 255 character limit.
	 *
	 * We only take 8 characters from the md5 hash (0.000005 chance of collision).
	 *
	 * Special cases:
	 *
	 * - If the path only contains a single component (i.e. it's a top-level
	 *   resource), we won't add the hash to it. The hash is not needed for
	 *   disamiguation and also, it allows for a more straightforward migration an
	 *   existing CloudFormation template to a CDK stack without logical ID changes
	 *   (or renames).
	 * - For aesthetic reasons, if the last components of the path are the same
	 *   (i.e. `L1/L2/Pipeline/Pipeline`), they will be de-duplicated to make the
	 *   resulting human portion of the ID more pleasing: `L1L2Pipeline<HASH>`
	 *   instead of `L1L2PipelinePipeline<HASH>`
	 * - If a component is named "Default" it will be omitted from the path. This
	 *   allows refactoring higher level abstractions around constructs without affecting
	 *   the IDs of already deployed resources.
	 * - If a component is named "Resource" it will be omitted from the user-visible
	 *   path, but included in the hash. This reduces visual noise in the human readable
	 *   part of the identifier.
	 *
	 * @param cfnElement The element for which the logical ID is allocated.
	 */
	protected allocateLogicalId(cfnElement: CfnElement): string;
	/**
	 * Validate stack name
	 *
	 * CloudFormation stack names can include dashes in addition to the regular identifier
	 * character classes, and we don't allow one of the magic markers.
	 *
	 * @internal
	 */
	protected _validateId(name: string): void;
	/**
	 * Returns the CloudFormation template for this stack by traversing
	 * the tree and invoking _toCloudFormation() on all Entity objects.
	 *
	 * @internal
	 */
	protected _toCloudFormation(): any;
	/**
	 * Determine the various stack environment attributes.
	 *
	 */
	private parseEnvironment;
	/**
	 * Maximum number of resources in the stack
	 *
	 * Set to 0 to mean "unlimited".
	 */
	private get maxResources();
	/**
	 * Check whether this stack has a (transitive) dependency on another stack
	 *
	 * Returns the list of reasons on the dependency path, or undefined
	 * if there is no dependency.
	 */
	private stackDependencyReasons;
	/**
	 * Calculate the stack name based on the construct path
	 *
	 * The stack name is the name under which we'll deploy the stack,
	 * and incorporates containing Stage names by default.
	 *
	 * Generally this looks a lot like how logical IDs are calculated.
	 * The stack name is calculated based on the construct root path,
	 * as follows:
	 *
	 * - Path is calculated with respect to containing App or Stage (if any)
	 * - If the path is one component long just use that component, otherwise
	 *   combine them with a hash.
	 *
	 * Since the hash is quite ugly and we'd like to avoid it if possible -- but
	 * we can't anymore in the general case since it has been written into legacy
	 * stacks. The introduction of Stages makes it possible to make this nicer however.
	 * When a Stack is nested inside a Stage, we use the path components below the
	 * Stage, and prefix the path components of the Stage before it.
	 */
	private generateStackName;
	/**
	 * The artifact ID for this stack
	 *
	 * Stack artifact ID is unique within the App's Cloud Assembly.
	 */
	private generateStackArtifactId;
	/**
	 * Generate an ID with respect to the given container construct.
	 */
	private generateStackId;
	/**
	 * Indicates whether the stack requires bundling or not
	 */
	get bundlingRequired(): boolean;
}
/**
 * CloudFormation template options for a stack.
 */
export interface ITemplateOptions {
	/**
	 * Gets or sets the description of this stack.
	 * If provided, it will be included in the CloudFormation template's "Description" attribute.
	 */
	description?: string;
	/**
	 * Gets or sets the AWSTemplateFormatVersion field of the CloudFormation template.
	 */
	templateFormatVersion?: string;
	/**
	 * Gets or sets the top-level template transform(s) for this stack (e.g. `["AWS::Serverless-2016-10-31"]`).
	 */
	transforms?: string[];
	/**
	 * Metadata associated with the CloudFormation template.
	 */
	metadata?: {
		[key: string]: any;
	};
}
/**
 * Options for the `stack.exportValue()` method
 */
export interface ExportValueOptions {
	/**
	 * The name of the export to create
	 *
	 * @default - A name is automatically chosen
	 */
	readonly name?: string;
}
declare abstract class CfnElement extends Construct {
	/**
	 * Returns `true` if a construct is a stack element (i.e. part of the
	 * synthesized cloudformation template).
	 *
	 * Uses duck-typing instead of `instanceof` to allow stack elements from different
	 * versions of this library to be included in the same stack.
	 *
	 * @returns The construct as a stack element or undefined if it is not a stack element.
	 */
	static isCfnElement(x: any): x is CfnElement;
	/**
	 * The logical ID for this CloudFormation stack element. The logical ID of the element
	 * is calculated from the path of the resource node in the construct tree.
	 *
	 * To override this value, use `overrideLogicalId(newLogicalId)`.
	 *
	 * @returns the logical ID as a stringified token. This value will only get
	 * resolved during synthesis.
	 */
	readonly logicalId: string;
	/**
	 * The stack in which this element is defined. CfnElements must be defined within a stack scope (directly or indirectly).
	 */
	readonly stack: Stack;
	/**
	 * An explicit logical ID provided by `overrideLogicalId`.
	 */
	private _logicalIdOverride?;
	/**
	 * If the logicalId is locked then it can no longer be overridden.
	 * This is needed for cases where the logicalId is consumed prior to synthesis
	 * (i.e. Stack.exportValue).
	 */
	private _logicalIdLocked?;
	/**
	 * Creates an entity and binds it to a tree.
	 * Note that the root of the tree must be a Stack object (not just any Root).
	 *
	 * @param scope The parent construct
	 * @param props Construct properties
	 */
	constructor(scope: Construct, id: string);
	/**
	 * Overrides the auto-generated logical ID with a specific ID.
	 * @param newLogicalId The new logical ID to use for this stack element.
	 */
	overrideLogicalId(newLogicalId: string): void;
	/**
	 * Lock the logicalId of the element and do not allow
	 * any updates (e.g. via overrideLogicalId)
	 *
	 * This is needed in cases where you are consuming the LogicalID
	 * of an element prior to synthesis and you need to not allow future
	 * changes to the id since doing so would cause the value you just
	 * consumed to differ from the synth time value of the logicalId.
	 *
	 * For example:
	 *
	 * const bucket = new Bucket(stack, 'Bucket');
	 * stack.exportValue(bucket.bucketArn) <--- consuming the logicalId
	 * bucket.overrideLogicalId('NewLogicalId') <--- updating logicalId
	 *
	 * You should most likely never need to use this method, and if
	 * you are implementing a feature that requires this, make sure
	 * you actually require it.
	 *
	 * @internal
	 */
	_lockLogicalId(): void;
	/**
	 * @returns the stack trace of the point where this Resource was created from, sourced
	 *      from the +metadata+ entry typed +aws:cdk:logicalId+, and with the bottom-most
	 *      node +internal+ entries filtered.
	 */
	get creationStack(): string[];
	/**
	 * Returns the CloudFormation 'snippet' for this entity. The snippet will only be merged
	 * at the root level to ensure there are no identity conflicts.
	 *
	 * For example, a Resource class will return something like:
	 * {
	 *   Resources: {
	 *     [this.logicalId]: {
	 *       Type: this.resourceType,
	 *       Properties: this.props,
	 *       Condition: this.condition
	 *     }
	 *   }
	 * }
	 *
	 * @internal
	 */
	abstract _toCloudFormation(): object;
	/**
	 * Called during synthesize to render the logical ID of this element. If
	 * `overrideLogicalId` was it will be used, otherwise, we will allocate the
	 * logical ID through the stack.
	 */
	private synthesizeLogicalId;
}
declare abstract class CfnRefElement extends CfnElement {
	/**
	 * Return a string that will be resolved to a CloudFormation `{ Ref }` for this element.
	 *
	 * If, by any chance, the intrinsic reference of a resource is not a string, you could
	 * coerce it to an IResolvable through `Lazy.any({ produce: resource.ref })`.
	 */
	get ref(): string;
}
export interface CfnConditionProps {
	/**
	 * The expression that the condition will evaluate.
	 *
	 * @default - None.
	 */
	readonly expression?: ICfnConditionExpression;
}
declare class CfnCondition extends CfnElement implements ICfnConditionExpression, IResolvable {
	/**
	 * The condition statement.
	 */
	expression?: ICfnConditionExpression;
	/**
	 * Build a new condition. The condition must be constructed with a condition token,
	 * that the condition is based on.
	 */
	constructor(scope: Construct, id: string, props?: CfnConditionProps);
	/**
	 * @internal
	 */
	_toCloudFormation(): object;
	/**
	 * Synthesizes the condition.
	 */
	resolve(_context: IResolveContext): any;
}
/**
 * Represents a CloudFormation element that can be used within a Condition.
 *
 * You can use intrinsic functions, such as ``Fn.conditionIf``,
 * ``Fn.conditionEquals``, and ``Fn.conditionNot``, to conditionally create
 * stack resources. These conditions are evaluated based on input parameters
 * that you declare when you create or update a stack. After you define all your
 * conditions, you can associate them with resources or resource properties in
 * the Resources and Outputs sections of a template.
 *
 * You define all conditions in the Conditions section of a template except for
 * ``Fn.conditionIf`` conditions. You can use the ``Fn.conditionIf`` condition
 * in the metadata attribute, update policy attribute, and property values in
 * the Resources section and Outputs sections of a template.
 *
 * You might use conditions when you want to reuse a template that can create
 * resources in different contexts, such as a test environment versus a
 * production environment. In your template, you can add an EnvironmentType
 * input parameter, which accepts either prod or test as inputs. For the
 * production environment, you might include Amazon EC2 instances with certain
 * capabilities; however, for the test environment, you want to use less
 * capabilities to save costs. With conditions, you can define which resources
 * are created and how they're configured for each environment type.
 *
 * You can use `toString` when you wish to embed a condition expression
 * in a property value that accepts a `string`. For example:
 *
 * ```ts
 * new sqs.Queue(this, 'MyQueue', {
 *   queueName: Fn.conditionIf('Condition', 'Hello', 'World').toString()
 * });
 * ```
 */
export interface ICfnConditionExpression extends IResolvable {
}
/**
 * Associate the CreationPolicy attribute with a resource to prevent its status from reaching create complete until
 * AWS CloudFormation receives a specified number of success signals or the timeout period is exceeded. To signal a
 * resource, you can use the cfn-signal helper script or SignalResource API. AWS CloudFormation publishes valid signals
 * to the stack events so that you track the number of signals sent.
 *
 * The creation policy is invoked only when AWS CloudFormation creates the associated resource. Currently, the only
 * AWS CloudFormation resources that support creation policies are AWS::AutoScaling::AutoScalingGroup, AWS::EC2::Instance,
 * and AWS::CloudFormation::WaitCondition.
 *
 * Use the CreationPolicy attribute when you want to wait on resource configuration actions before stack creation proceeds.
 * For example, if you install and configure software applications on an EC2 instance, you might want those applications to
 * be running before proceeding. In such cases, you can add a CreationPolicy attribute to the instance, and then send a success
 * signal to the instance after the applications are installed and configured. For a detailed example, see Deploying Applications
 * on Amazon EC2 with AWS CloudFormation.
 */
export interface CfnCreationPolicy {
	/**
	 * For an Auto Scaling group replacement update, specifies how many instances must signal success for the
	 * update to succeed.
	 */
	readonly autoScalingCreationPolicy?: CfnResourceAutoScalingCreationPolicy;
	/**
	 * When AWS CloudFormation creates the associated resource, configures the number of required success signals and
	 * the length of time that AWS CloudFormation waits for those signals.
	 */
	readonly resourceSignal?: CfnResourceSignal;
}
/**
 * For an Auto Scaling group replacement update, specifies how many instances must signal success for the
 * update to succeed.
 */
export interface CfnResourceAutoScalingCreationPolicy {
	/**
	 * Specifies the percentage of instances in an Auto Scaling replacement update that must signal success for the
	 * update to succeed. You can specify a value from 0 to 100. AWS CloudFormation rounds to the nearest tenth of a percent.
	 * For example, if you update five instances with a minimum successful percentage of 50, three instances must signal success.
	 * If an instance doesn't send a signal within the time specified by the Timeout property, AWS CloudFormation assumes that the
	 * instance wasn't created.
	 */
	readonly minSuccessfulInstancesPercent?: number;
}
/**
 * When AWS CloudFormation creates the associated resource, configures the number of required success signals and
 * the length of time that AWS CloudFormation waits for those signals.
 */
export interface CfnResourceSignal {
	/**
	 * The number of success signals AWS CloudFormation must receive before it sets the resource status as CREATE_COMPLETE.
	 * If the resource receives a failure signal or doesn't receive the specified number of signals before the timeout period
	 * expires, the resource creation fails and AWS CloudFormation rolls the stack back.
	 */
	readonly count?: number;
	/**
	 * The length of time that AWS CloudFormation waits for the number of signals that was specified in the Count property.
	 * The timeout period starts after AWS CloudFormation starts creating the resource, and the timeout expires no sooner
	 * than the time you specify but can occur shortly thereafter. The maximum time that you can specify is 12 hours.
	 */
	readonly timeout?: string;
}
declare enum CfnDeletionPolicy {
	/**
	 * AWS CloudFormation deletes the resource and all its content if applicable during stack deletion. You can add this
	 * deletion policy to any resource type. By default, if you don't specify a DeletionPolicy, AWS CloudFormation deletes
	 * your resources. However, be aware of the following considerations:
	 */
	DELETE = "Delete",
	/**
	 * AWS CloudFormation keeps the resource without deleting the resource or its contents when its stack is deleted.
	 * You can add this deletion policy to any resource type. Note that when AWS CloudFormation completes the stack deletion,
	 * the stack will be in Delete_Complete state; however, resources that are retained continue to exist and continue to incur
	 * applicable charges until you delete those resources.
	 */
	RETAIN = "Retain",
	/**
	 * For resources that support snapshots (AWS::EC2::Volume, AWS::ElastiCache::CacheCluster, AWS::ElastiCache::ReplicationGroup,
	 * AWS::RDS::DBInstance, AWS::RDS::DBCluster, and AWS::Redshift::Cluster), AWS CloudFormation creates a snapshot for the
	 * resource before deleting it. Note that when AWS CloudFormation completes the stack deletion, the stack will be in the
	 * Delete_Complete state; however, the snapshots that are created with this policy continue to exist and continue to
	 * incur applicable charges until you delete those snapshots.
	 */
	SNAPSHOT = "Snapshot"
}
/**
 * Use the UpdatePolicy attribute to specify how AWS CloudFormation handles updates to the AWS::AutoScaling::AutoScalingGroup
 * resource. AWS CloudFormation invokes one of three update policies depending on the type of change you make or whether a
 * scheduled action is associated with the Auto Scaling group.
 */
export interface CfnUpdatePolicy {
	/**
	 * Specifies whether an Auto Scaling group and the instances it contains are replaced during an update. During replacement,
	 * AWS CloudFormation retains the old group until it finishes creating the new one. If the update fails, AWS CloudFormation
	 * can roll back to the old Auto Scaling group and delete the new Auto Scaling group.
	 */
	readonly autoScalingReplacingUpdate?: CfnAutoScalingReplacingUpdate;
	/**
	 * To specify how AWS CloudFormation handles rolling updates for an Auto Scaling group, use the AutoScalingRollingUpdate
	 * policy. Rolling updates enable you to specify whether AWS CloudFormation updates instances that are in an Auto Scaling
	 * group in batches or all at once.
	 */
	readonly autoScalingRollingUpdate?: CfnAutoScalingRollingUpdate;
	/**
	 * To specify how AWS CloudFormation handles updates for the MinSize, MaxSize, and DesiredCapacity properties when
	 * the AWS::AutoScaling::AutoScalingGroup resource has an associated scheduled action, use the AutoScalingScheduledAction
	 * policy.
	 */
	readonly autoScalingScheduledAction?: CfnAutoScalingScheduledAction;
	/**
	 * To perform an AWS CodeDeploy deployment when the version changes on an AWS::Lambda::Alias resource,
	 * use the CodeDeployLambdaAliasUpdate update policy.
	 */
	readonly codeDeployLambdaAliasUpdate?: CfnCodeDeployLambdaAliasUpdate;
	/**
	 * To modify a replication group's shards by adding or removing shards, rather than replacing the entire
	 * AWS::ElastiCache::ReplicationGroup resource, use the UseOnlineResharding update policy.
	 */
	readonly useOnlineResharding?: boolean;
	/**
	 * To upgrade an Amazon ES domain to a new version of Elasticsearch rather than replacing the entire
	 * AWS::Elasticsearch::Domain resource, use the EnableVersionUpgrade update policy.
	 */
	readonly enableVersionUpgrade?: boolean;
}
/**
 * To specify how AWS CloudFormation handles rolling updates for an Auto Scaling group, use the AutoScalingRollingUpdate
 * policy. Rolling updates enable you to specify whether AWS CloudFormation updates instances that are in an Auto Scaling
 * group in batches or all at once.
 */
export interface CfnAutoScalingRollingUpdate {
	/**
	 * Specifies the maximum number of instances that AWS CloudFormation updates.
	 */
	readonly maxBatchSize?: number;
	/**
	 * Specifies the minimum number of instances that must be in service within the Auto Scaling group while AWS
	 * CloudFormation updates old instances.
	 */
	readonly minInstancesInService?: number;
	/**
	 * Specifies the percentage of instances in an Auto Scaling rolling update that must signal success for an update to succeed.
	 * You can specify a value from 0 to 100. AWS CloudFormation rounds to the nearest tenth of a percent. For example, if you
	 * update five instances with a minimum successful percentage of 50, three instances must signal success.
	 *
	 * If an instance doesn't send a signal within the time specified in the PauseTime property, AWS CloudFormation assumes
	 * that the instance wasn't updated.
	 *
	 * If you specify this property, you must also enable the WaitOnResourceSignals and PauseTime properties.
	 */
	readonly minSuccessfulInstancesPercent?: number;
	/**
	 * The amount of time that AWS CloudFormation pauses after making a change to a batch of instances to give those instances
	 * time to start software applications. For example, you might need to specify PauseTime when scaling up the number of
	 * instances in an Auto Scaling group.
	 *
	 * If you enable the WaitOnResourceSignals property, PauseTime is the amount of time that AWS CloudFormation should wait
	 * for the Auto Scaling group to receive the required number of valid signals from added or replaced instances. If the
	 * PauseTime is exceeded before the Auto Scaling group receives the required number of signals, the update fails. For best
	 * results, specify a time period that gives your applications sufficient time to get started. If the update needs to be
	 * rolled back, a short PauseTime can cause the rollback to fail.
	 *
	 * Specify PauseTime in the ISO8601 duration format (in the format PT#H#M#S, where each # is the number of hours, minutes,
	 * and seconds, respectively). The maximum PauseTime is one hour (PT1H).
	 */
	readonly pauseTime?: string;
	/**
	 * Specifies the Auto Scaling processes to suspend during a stack update. Suspending processes prevents Auto Scaling from
	 * interfering with a stack update. For example, you can suspend alarming so that Auto Scaling doesn't execute scaling
	 * policies associated with an alarm. For valid values, see the ScalingProcesses.member.N parameter for the SuspendProcesses
	 * action in the Auto Scaling API Reference.
	 */
	readonly suspendProcesses?: string[];
	/**
	 * Specifies whether the Auto Scaling group waits on signals from new instances during an update. Use this property to
	 * ensure that instances have completed installing and configuring applications before the Auto Scaling group update proceeds.
	 * AWS CloudFormation suspends the update of an Auto Scaling group after new EC2 instances are launched into the group.
	 * AWS CloudFormation must receive a signal from each new instance within the specified PauseTime before continuing the update.
	 * To signal the Auto Scaling group, use the cfn-signal helper script or SignalResource API.
	 *
	 * To have instances wait for an Elastic Load Balancing health check before they signal success, add a health-check
	 * verification by using the cfn-init helper script. For an example, see the verify_instance_health command in the Auto Scaling
	 * rolling updates sample template.
	 */
	readonly waitOnResourceSignals?: boolean;
}
/**
 * Specifies whether an Auto Scaling group and the instances it contains are replaced during an update. During replacement,
 * AWS CloudFormation retains the old group until it finishes creating the new one. If the update fails, AWS CloudFormation
 * can roll back to the old Auto Scaling group and delete the new Auto Scaling group.
 *
 * While AWS CloudFormation creates the new group, it doesn't detach or attach any instances. After successfully creating
 * the new Auto Scaling group, AWS CloudFormation deletes the old Auto Scaling group during the cleanup process.
 *
 * When you set the WillReplace parameter, remember to specify a matching CreationPolicy. If the minimum number of
 * instances (specified by the MinSuccessfulInstancesPercent property) don't signal success within the Timeout period
 * (specified in the CreationPolicy policy), the replacement update fails and AWS CloudFormation rolls back to the old
 * Auto Scaling group.
 */
export interface CfnAutoScalingReplacingUpdate {
	readonly willReplace?: boolean;
}
/**
 * With scheduled actions, the group size properties of an Auto Scaling group can change at any time. When you update a
 * stack with an Auto Scaling group and scheduled action, AWS CloudFormation always sets the group size property values of
 * your Auto Scaling group to the values that are defined in the AWS::AutoScaling::AutoScalingGroup resource of your template,
 * even if a scheduled action is in effect.
 *
 * If you do not want AWS CloudFormation to change any of the group size property values when you have a scheduled action in
 * effect, use the AutoScalingScheduledAction update policy to prevent AWS CloudFormation from changing the MinSize, MaxSize,
 * or DesiredCapacity properties unless you have modified these values in your template.\
 */
export interface CfnAutoScalingScheduledAction {
	readonly ignoreUnmodifiedGroupSizeProperties?: boolean;
}
/**
 * To perform an AWS CodeDeploy deployment when the version changes on an AWS::Lambda::Alias resource,
 * use the CodeDeployLambdaAliasUpdate update policy.
 */
export interface CfnCodeDeployLambdaAliasUpdate {
	/**
	 * The name of the AWS CodeDeploy application.
	 */
	readonly applicationName: string;
	/**
	 * The name of the AWS CodeDeploy deployment group. This is where the traffic-shifting policy is set.
	 */
	readonly deploymentGroupName: string;
	/**
	 * The name of the Lambda function to run before traffic routing starts.
	 */
	readonly beforeAllowTrafficHook?: string;
	/**
	 * The name of the Lambda function to run after traffic routing completes.
	 */
	readonly afterAllowTrafficHook?: string;
}
declare enum RemovalPolicy {
	/**
	 * This is the default removal policy. It means that when the resource is
	 * removed from the app, it will be physically destroyed.
	 */
	DESTROY = "destroy",
	/**
	 * This uses the 'Retain' DeletionPolicy, which will cause the resource to be retained
	 * in the account, but orphaned from the stack.
	 */
	RETAIN = "retain",
	/**
	 * This retention policy deletes the resource,
	 * but saves a snapshot of its data before deleting,
	 * so that it can be re-created later.
	 * Only available for some stateful resources,
	 * like databases, EC2 volumes, etc.
	 *
	 * @see https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options
	 */
	SNAPSHOT = "snapshot"
}
export interface RemovalPolicyOptions {
	/**
	 * The default policy to apply in case the removal policy is not defined.
	 *
	 * @default - Default value is resource specific. To determine the default value for a resoure,
	 * please consult that specific resource's documentation.
	 */
	readonly default?: RemovalPolicy;
	/**
	 * Apply the same deletion policy to the resource's "UpdateReplacePolicy"
	 * @default true
	 */
	readonly applyToUpdateReplacePolicy?: boolean;
}
export interface CfnResourceProps {
	/**
	 * CloudFormation resource type (e.g. `AWS::S3::Bucket`).
	 */
	readonly type: string;
	/**
	 * Resource properties.
	 *
	 * @default - No resource properties.
	 */
	readonly properties?: {
		[name: string]: any;
	};
}
declare class CfnResource extends CfnRefElement {
	/**
	 * Check whether the given construct is a CfnResource
	 */
	static isCfnResource(construct: IConstruct): construct is CfnResource;
	/**
	 * Options for this resource, such as condition, update policy etc.
	 */
	readonly cfnOptions: ICfnResourceOptions;
	/**
	 * AWS resource type.
	 */
	readonly cfnResourceType: string;
	/**
	 * AWS CloudFormation resource properties.
	 *
	 * This object is returned via cfnProperties
	 * @internal
	 */
	protected readonly _cfnProperties: any;
	/**
	 * An object to be merged on top of the entire resource definition.
	 */
	private readonly rawOverrides;
	/**
	 * Logical IDs of dependencies.
	 *
	 * Is filled during prepare().
	 */
	private readonly dependsOn;
	/**
	 * Creates a resource construct.
	 * @param cfnResourceType The CloudFormation type of this resource (e.g. AWS::DynamoDB::Table)
	 */
	constructor(scope: Construct, id: string, props: CfnResourceProps);
	/**
	 * Sets the deletion policy of the resource based on the removal policy specified.
	 *
	 * The Removal Policy controls what happens to this resource when it stops
	 * being managed by CloudFormation, either because you've removed it from the
	 * CDK application or because you've made a change that requires the resource
	 * to be replaced.
	 *
	 * The resource can be deleted (`RemovalPolicy.DESTROY`), or left in your AWS
	 * account for data recovery and cleanup later (`RemovalPolicy.RETAIN`). In some
	 * cases, a snapshot can be taken of the resource prior to deletion
	 * (`RemovalPolicy.SNAPSHOT`). A list of resources that support this policy
	 * can be found in the following link:
	 *
	 * @see https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options
	 */
	applyRemovalPolicy(policy: RemovalPolicy | undefined, options?: RemovalPolicyOptions): void;
	/**
	 * Returns a token for an runtime attribute of this resource.
	 * Ideally, use generated attribute accessors (e.g. `resource.arn`), but this can be used for future compatibility
	 * in case there is no generated attribute.
	 * @param attributeName The name of the attribute.
	 */
	getAtt(attributeName: string): Reference;
	/**
	 * Adds an override to the synthesized CloudFormation resource. To add a
	 * property override, either use `addPropertyOverride` or prefix `path` with
	 * "Properties." (i.e. `Properties.TopicName`).
	 *
	 * If the override is nested, separate each nested level using a dot (.) in the path parameter.
	 * If there is an array as part of the nesting, specify the index in the path.
	 *
	 * To include a literal `.` in the property name, prefix with a `\`. In most
	 * programming languages you will need to write this as `"\\."` because the
	 * `\` itself will need to be escaped.
	 *
	 * For example,
	 * ```typescript
	 * cfnResource.addOverride('Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes', ['myattribute']);
	 * cfnResource.addOverride('Properties.GlobalSecondaryIndexes.1.ProjectionType', 'INCLUDE');
	 * ```
	 * would add the overrides
	 * ```json
	 * "Properties": {
	 *   "GlobalSecondaryIndexes": [
	 *     {
	 *       "Projection": {
	 *         "NonKeyAttributes": [ "myattribute" ]
	 *         ...
	 *       }
	 *       ...
	 *     },
	 *     {
	 *       "ProjectionType": "INCLUDE"
	 *       ...
	 *     },
	 *   ]
	 *   ...
	 * }
	 * ```
	 *
	 * The `value` argument to `addOverride` will not be processed or translated
	 * in any way. Pass raw JSON values in here with the correct capitalization
	 * for CloudFormation. If you pass CDK classes or structs, they will be
	 * rendered with lowercased key names, and CloudFormation will reject the
	 * template.
	 *
	 * @param path - The path of the property, you can use dot notation to
	 *        override values in complex types. Any intermdediate keys
	 *        will be created as needed.
	 * @param value - The value. Could be primitive or complex.
	 */
	addOverride(path: string, value: any): void;
	/**
	 * Syntactic sugar for `addOverride(path, undefined)`.
	 * @param path The path of the value to delete
	 */
	addDeletionOverride(path: string): void;
	/**
	 * Adds an override to a resource property.
	 *
	 * Syntactic sugar for `addOverride("Properties.<...>", value)`.
	 *
	 * @param propertyPath The path of the property
	 * @param value The value
	 */
	addPropertyOverride(propertyPath: string, value: any): void;
	/**
	 * Adds an override that deletes the value of a property from the resource definition.
	 * @param propertyPath The path to the property.
	 */
	addPropertyDeletionOverride(propertyPath: string): void;
	/**
	 * Indicates that this resource depends on another resource and cannot be
	 * provisioned unless the other resource has been successfully provisioned.
	 *
	 * This can be used for resources across stacks (or nested stack) boundaries
	 * and the dependency will automatically be transferred to the relevant scope.
	 */
	addDependsOn(target: CfnResource): void;
	/**
	 * Add a value to the CloudFormation Resource Metadata
	 * @see https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html
	 *
	 * Note that this is a different set of metadata from CDK node metadata; this
	 * metadata ends up in the stack template under the resource, whereas CDK
	 * node metadata ends up in the Cloud Assembly.
	 */
	addMetadata(key: string, value: any): void;
	/**
	 * Retrieve a value value from the CloudFormation Resource Metadata
	 * @see https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html
	 *
	 * Note that this is a different set of metadata from CDK node metadata; this
	 * metadata ends up in the stack template under the resource, whereas CDK
	 * node metadata ends up in the Cloud Assembly.
	 */
	getMetadata(key: string): any;
	/**
	 * @returns a string representation of this resource
	 */
	toString(): string;
	/**
	 * Called by the `addDependency` helper function in order to realize a direct
	 * dependency between two resources that are directly defined in the same
	 * stacks.
	 *
	 * Use `resource.addDependsOn` to define the dependency between two resources,
	 * which also takes stack boundaries into account.
	 *
	 * @internal
	 */
	_addResourceDependency(target: CfnResource): void;
	/**
	 * Emits CloudFormation for this resource.
	 * @internal
	 */
	_toCloudFormation(): object;
	protected get cfnProperties(): {
		[key: string]: any;
	};
	protected renderProperties(props: {
		[key: string]: any;
	}): {
		[key: string]: any;
	};
	/**
	 * Deprecated
	 * @deprecated use `updatedProperties`
	 *
	 * Return properties modified after initiation
	 *
	 * Resources that expose mutable properties should override this function to
	 * collect and return the properties object for this resource.
	 */
	protected get updatedProperites(): {
		[key: string]: any;
	};
	/**
	 * Return properties modified after initiation
	 *
	 * Resources that expose mutable properties should override this function to
	 * collect and return the properties object for this resource.
	 */
	protected get updatedProperties(): {
		[key: string]: any;
	};
	protected validateProperties(_properties: any): void;
	/**
	 * Can be overridden by subclasses to determine if this resource will be rendered
	 * into the cloudformation template.
	 *
	 * @returns `true` if the resource should be included or `false` is the resource
	 * should be omitted.
	 */
	protected shouldSynthesize(): boolean;
}
declare enum TagType {
	STANDARD = "StandardTag",
	AUTOSCALING_GROUP = "AutoScalingGroupTag",
	MAP = "StringToStringMap",
	KEY_VALUE = "KeyValue",
	NOT_TAGGABLE = "NotTaggable"
}
export interface ICfnResourceOptions {
	/**
	 * A condition to associate with this resource. This means that only if the condition evaluates to 'true' when the stack
	 * is deployed, the resource will be included. This is provided to allow CDK projects to produce legacy templates, but normally
	 * there is no need to use it in CDK projects.
	 */
	condition?: CfnCondition;
	/**
	 * Associate the CreationPolicy attribute with a resource to prevent its status from reaching create complete until
	 * AWS CloudFormation receives a specified number of success signals or the timeout period is exceeded. To signal a
	 * resource, you can use the cfn-signal helper script or SignalResource API. AWS CloudFormation publishes valid signals
	 * to the stack events so that you track the number of signals sent.
	 */
	creationPolicy?: CfnCreationPolicy;
	/**
	 * With the DeletionPolicy attribute you can preserve or (in some cases) backup a resource when its stack is deleted.
	 * You specify a DeletionPolicy attribute for each resource that you want to control. If a resource has no DeletionPolicy
	 * attribute, AWS CloudFormation deletes the resource by default. Note that this capability also applies to update operations
	 * that lead to resources being removed.
	 */
	deletionPolicy?: CfnDeletionPolicy;
	/**
	 * Use the UpdatePolicy attribute to specify how AWS CloudFormation handles updates to the AWS::AutoScaling::AutoScalingGroup
	 * resource. AWS CloudFormation invokes one of three update policies depending on the type of change you make or whether a
	 * scheduled action is associated with the Auto Scaling group.
	 */
	updatePolicy?: CfnUpdatePolicy;
	/**
	 * Use the UpdateReplacePolicy attribute to retain or (in some cases) backup the existing physical instance of a resource
	 * when it is replaced during a stack update operation.
	 */
	updateReplacePolicy?: CfnDeletionPolicy;
	/**
	 * The version of this resource.
	 * Used only for custom CloudFormation resources.
	 *
	 * @see https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-cfn-customresource.html
	 */
	version?: string;
	/**
	 * The description of this resource.
	 * Used for informational purposes only, is not processed in any way
	 * (and stays with the CloudFormation template, is not passed to the underlying resource,
	 * even if it does have a 'description' property).
	 */
	description?: string;
	/**
	 * Metadata associated with the CloudFormation resource. This is not the same as the construct metadata which can be added
	 * using construct.addMetadata(), but would not appear in the CloudFormation template automatically.
	 */
	metadata?: {
		[key: string]: any;
	};
}
/**
 * Interface to implement tags.
 */
export interface ITaggable {
	/**
	 * TagManager to set, remove and format tags
	 */
	readonly tags: TagManager;
}
/**
 * Options to configure TagManager behavior
 */
export interface TagManagerOptions {
	/**
	 * The name of the property in CloudFormation for these tags
	 *
	 * Normally this is `tags`, but Cognito UserPool uses UserPoolTags
	 *
	 * @default "tags"
	 */
	readonly tagPropertyName?: string;
}
declare class TagManager {
	/**
	 * Check whether the given construct is Taggable
	 */
	static isTaggable(construct: any): construct is ITaggable;
	/**
	 * The property name for tag values
	 *
	 * Normally this is `tags` but some resources choose a different name. Cognito
	 * UserPool uses UserPoolTags
	 */
	readonly tagPropertyName: string;
	/**
	 * A lazy value that represents the rendered tags at synthesis time
	 *
	 * If you need to make a custom construct taggable, use the value of this
	 * property to pass to the `tags` property of the underlying construct.
	 */
	readonly renderedTags: IResolvable;
	private readonly tags;
	private readonly dynamicTags;
	private readonly priorities;
	private readonly tagFormatter;
	private readonly resourceTypeName;
	private readonly initialTagPriority;
	constructor(tagType: TagType, resourceTypeName: string, tagStructure?: any, options?: TagManagerOptions);
	/**
	 * Adds the specified tag to the array of tags
	 *
	 */
	setTag(key: string, value: string, priority?: number, applyToLaunchedInstances?: boolean): void;
	/**
	 * Removes the specified tag from the array if it exists
	 *
	 * @param key The tag to remove
	 * @param priority The priority of the remove operation
	 */
	removeTag(key: string, priority: number): void;
	/**
	 * Renders tags into the proper format based on TagType
	 *
	 * This method will eagerly render the tags currently applied. In
	 * most cases, you should be using `tagManager.renderedTags` instead,
	 * which will return a `Lazy` value that will resolve to the correct
	 * tags at synthesis time.
	 */
	renderTags(): any;
	/**
	 * Render the tags in a readable format
	 */
	tagValues(): Record<string, string>;
	/**
	 * Determine if the aspect applies here
	 *
	 * Looks at the include and exclude resourceTypeName arrays to determine if
	 * the aspect applies here
	 */
	applyTagAspectHere(include?: string[], exclude?: string[]): boolean;
	/**
	 * Returns true if there are any tags defined
	 */
	hasTags(): boolean;
	private _setTag;
	private get sortedTags();
}
declare class Duration {
	/**
	 * Create a Duration representing an amount of milliseconds
	 *
	 * @param amount the amount of Milliseconds the `Duration` will represent.
	 * @returns a new `Duration` representing `amount` ms.
	 */
	static millis(amount: number): Duration;
	/**
	 * Create a Duration representing an amount of seconds
	 *
	 * @param amount the amount of Seconds the `Duration` will represent.
	 * @returns a new `Duration` representing `amount` Seconds.
	 */
	static seconds(amount: number): Duration;
	/**
	 * Create a Duration representing an amount of minutes
	 *
	 * @param amount the amount of Minutes the `Duration` will represent.
	 * @returns a new `Duration` representing `amount` Minutes.
	 */
	static minutes(amount: number): Duration;
	/**
	 * Create a Duration representing an amount of hours
	 *
	 * @param amount the amount of Hours the `Duration` will represent.
	 * @returns a new `Duration` representing `amount` Hours.
	 */
	static hours(amount: number): Duration;
	/**
	 * Create a Duration representing an amount of days
	 *
	 * @param amount the amount of Days the `Duration` will represent.
	 * @returns a new `Duration` representing `amount` Days.
	 */
	static days(amount: number): Duration;
	/**
	 * Parse a period formatted according to the ISO 8601 standard
	 *
	 * @see https://www.iso.org/standard/70907.html
	 * @param duration an ISO-formtted duration to be parsed.
	 * @returns the parsed `Duration`.
	 */
	static parse(duration: string): Duration;
	private readonly amount;
	private readonly unit;
	private constructor();
	/**
	 * Add two Durations together
	 */
	plus(rhs: Duration): Duration;
	/**
	 * Substract two Durations together
	 */
	minus(rhs: Duration): Duration;
	/**
	 * Return the total number of milliseconds in this Duration
	 *
	 * @returns the value of this `Duration` expressed in Milliseconds.
	 */
	toMilliseconds(opts?: TimeConversionOptions): number;
	/**
	 * Return the total number of seconds in this Duration
	 *
	 * @returns the value of this `Duration` expressed in Seconds.
	 */
	toSeconds(opts?: TimeConversionOptions): number;
	/**
	 * Return the total number of minutes in this Duration
	 *
	 * @returns the value of this `Duration` expressed in Minutes.
	 */
	toMinutes(opts?: TimeConversionOptions): number;
	/**
	 * Return the total number of hours in this Duration
	 *
	 * @returns the value of this `Duration` expressed in Hours.
	 */
	toHours(opts?: TimeConversionOptions): number;
	/**
	 * Return the total number of days in this Duration
	 *
	 * @returns the value of this `Duration` expressed in Days.
	 */
	toDays(opts?: TimeConversionOptions): number;
	/**
	 * Return an ISO 8601 representation of this period
	 *
	 * @returns a string starting with 'P' describing the period
	 * @see https://www.iso.org/standard/70907.html
	 */
	toIsoString(): string;
	/**
	 * Turn this duration into a human-readable string
	 */
	toHumanString(): string;
	/**
	 * Returns a string representation of this `Duration`
	 *
	 * This is is never the right function to use when you want to use the `Duration`
	 * object in a template. Use `toSeconds()`, `toMinutes()`, `toDays()`, etc. instead.
	 */
	toString(): string;
	/**
	 * Return the duration in a set of whole numbered time components, ordered from largest to smallest
	 *
	 * Only components != 0 will be returned.
	 *
	 * Can combine millis and seconds together for the benefit of toIsoString,
	 * makes the logic in there simpler.
	 */
	private components;
	/**
	 * Checks if duration is a token or a resolvable object
	 */
	isUnresolved(): boolean;
	/**
	 * Returns unit of the duration
	 */
	unitLabel(): string;
	/**
	 * Returns stringified number of duration
	 */
	formatTokenToNumber(): string;
}
/**
 * Options for how to convert time to a different unit.
 */
export interface TimeConversionOptions {
	/**
	 * If `true`, conversions into a larger time unit (e.g. `Seconds` to `Minutes`) will fail if the result is not an
	 * integer.
	 *
	 * @default true
	 */
	readonly integral?: boolean;
}
/**
 * Represents the environment a given resource lives in.
 * Used as the return value for the {@link IResource.env} property.
 */
export interface ResourceEnvironment {
	/**
	 * The AWS account ID that this resource belongs to.
	 * Since this can be a Token
	 * (for example, when the account is CloudFormation's AWS::AccountId intrinsic),
	 * make sure to use Token.compareStrings()
	 * instead of just comparing the values for equality.
	 */
	readonly account: string;
	/**
	 * The AWS region that this resource belongs to.
	 * Since this can be a Token
	 * (for example, when the region is CloudFormation's AWS::Region intrinsic),
	 * make sure to use Token.compareStrings()
	 * instead of just comparing the values for equality.
	 */
	readonly region: string;
}
/**
 * Interface for the Resource construct.
 */
export interface IResource extends IConstruct {
	/**
	 * The stack in which this resource is defined.
	 */
	readonly stack: Stack;
	/**
	 * The environment this resource belongs to.
	 * For resources that are created and managed by the CDK
	 * (generally, those created by creating new class instances like Role, Bucket, etc.),
	 * this is always the same as the environment of the stack they belong to;
	 * however, for imported resources
	 * (those obtained from static methods like fromRoleArn, fromBucketName, etc.),
	 * that might be different than the stack they were imported into.
	 */
	readonly env: ResourceEnvironment;
	/**
	 * Apply the given removal policy to this resource
	 *
	 * The Removal Policy controls what happens to this resource when it stops
	 * being managed by CloudFormation, either because you've removed it from the
	 * CDK application or because you've made a change that requires the resource
	 * to be replaced.
	 *
	 * The resource can be deleted (`RemovalPolicy.DESTROY`), or left in your AWS
	 * account for data recovery and cleanup later (`RemovalPolicy.RETAIN`).
	 */
	applyRemovalPolicy(policy: RemovalPolicy): void;
}
/**
 * Construction properties for {@link Resource}.
 */
export interface ResourceProps {
	/**
	 * The value passed in by users to the physical name prop of the resource.
	 *
	 * - `undefined` implies that a physical name will be allocated by
	 *   CloudFormation during deployment.
	 * - a concrete value implies a specific physical name
	 * - `PhysicalName.GENERATE_IF_NEEDED` is a marker that indicates that a physical will only be generated
	 *   by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation.
	 *
	 * @default - The physical name will be allocated by CloudFormation at deployment time
	 */
	readonly physicalName?: string;
	/**
	 * The AWS account ID this resource belongs to.
	 *
	 * @default - the resource is in the same account as the stack it belongs to
	 */
	readonly account?: string;
	/**
	 * The AWS region this resource belongs to.
	 *
	 * @default - the resource is in the same region as the stack it belongs to
	 */
	readonly region?: string;
	/**
	 * ARN to deduce region and account from
	 *
	 * The ARN is parsed and the account and region are taken from the ARN.
	 * This should be used for imported resources.
	 *
	 * Cannot be supplied together with either `account` or `region`.
	 *
	 * @default - take environment from `account`, `region` parameters, or use Stack environment.
	 */
	readonly environmentFromArn?: string;
}
declare abstract class Resource extends Construct implements IResource {
	/**
	 * Check whether the given construct is a Resource
	 */
	static isResource(construct: IConstruct): construct is Resource;
	/**
	 * Returns true if the construct was created by CDK, and false otherwise
	 */
	static isOwnedResource(construct: IConstruct): boolean;
	readonly stack: Stack;
	readonly env: ResourceEnvironment;
	/**
	 * Returns a string-encoded token that resolves to the physical name that
	 * should be passed to the CloudFormation resource.
	 *
	 * This value will resolve to one of the following:
	 * - a concrete value (e.g. `"my-awesome-bucket"`)
	 * - `undefined`, when a name should be generated by CloudFormation
	 * - a concrete name generated automatically during synthesis, in
	 *   cross-environment scenarios.
	 *
	 */
	protected readonly physicalName: string;
	private _physicalName;
	private readonly _allowCrossEnvironment;
	constructor(scope: Construct, id: string, props?: ResourceProps);
	/**
	 * Called when this resource is referenced across environments
	 * (account/region) to order to request that a physical name will be generated
	 * for this resource during synthesis, so the resource can be referenced
	 * through it's absolute name/arn.
	 *
	 * @internal
	 */
	_enableCrossEnvironment(): void;
	/**
	 * Apply the given removal policy to this resource
	 *
	 * The Removal Policy controls what happens to this resource when it stops
	 * being managed by CloudFormation, either because you've removed it from the
	 * CDK application or because you've made a change that requires the resource
	 * to be replaced.
	 *
	 * The resource can be deleted (`RemovalPolicy.DESTROY`), or left in your AWS
	 * account for data recovery and cleanup later (`RemovalPolicy.RETAIN`).
	 */
	applyRemovalPolicy(policy: RemovalPolicy): void;
	protected generatePhysicalName(): string;
	/**
	 * Returns an environment-sensitive token that should be used for the
	 * resource's "name" attribute (e.g. `bucket.bucketName`).
	 *
	 * Normally, this token will resolve to `nameAttr`, but if the resource is
	 * referenced across environments, it will be resolved to `this.physicalName`,
	 * which will be a concrete name.
	 *
	 * @param nameAttr The CFN attribute which resolves to the resource's name.
	 * Commonly this is the resource's `ref`.
	 */
	protected getResourceNameAttribute(nameAttr: string): string;
	/**
	 * Returns an environment-sensitive token that should be used for the
	 * resource's "ARN" attribute (e.g. `bucket.bucketArn`).
	 *
	 * Normally, this token will resolve to `arnAttr`, but if the resource is
	 * referenced across environments, `arnComponents` will be used to synthesize
	 * a concrete ARN with the resource's physical name. Make sure to reference
	 * `this.physicalName` in `arnComponents`.
	 *
	 * @param arnAttr The CFN attribute which resolves to the ARN of the resource.
	 * Commonly it will be called "Arn" (e.g. `resource.attrArn`), but sometimes
	 * it's the CFN resource's `ref`.
	 * @param arnComponents The format of the ARN of this resource. You must
	 * reference `this.physicalName` somewhere within the ARN in order for
	 * cross-environment references to work.
	 *
	 */
	protected getResourceArnAttribute(arnAttr: string, arnComponents: ArnComponents): string;
}
/**
 * Any object that has an associated principal that a permission can be granted to
 */
export interface IGrantable {
	/**
	 * The principal to grant permissions to
	 */
	readonly grantPrincipal: IPrincipal;
}
/**
 * Represents a logical IAM principal.
 *
 * An IPrincipal describes a logical entity that can perform AWS API calls
 * against sets of resources, optionally under certain conditions.
 *
 * Examples of simple principals are IAM objects that you create, such
 * as Users or Roles.
 *
 * An example of a more complex principals is a `ServicePrincipal` (such as
 * `new ServicePrincipal("sns.amazonaws.com")`, which represents the Simple
 * Notifications Service).
 *
 * A single logical Principal may also map to a set of physical principals.
 * For example, `new OrganizationPrincipal('o-1234')` represents all
 * identities that are part of the given AWS Organization.
 */
export interface IPrincipal extends IGrantable {
	/**
	 * When this Principal is used in an AssumeRole policy, the action to use.
	 */
	readonly assumeRoleAction: string;
	/**
	 * Return the policy fragment that identifies this principal in a Policy.
	 */
	readonly policyFragment: PrincipalPolicyFragment;
	/**
	 * The AWS account ID of this principal.
	 * Can be undefined when the account is not known
	 * (for example, for service principals).
	 * Can be a Token - in that case,
	 * it's assumed to be AWS::AccountId.
	 */
	readonly principalAccount?: string;
	/**
	 * Add to the policy of this principal.
	 */
	addToPrincipalPolicy(statement: PolicyStatement): AddToPrincipalPolicyResult;
}
/**
 * Result of calling `addToPrincipalPolicy`
 */
export interface AddToPrincipalPolicyResult {
	/**
	 * Whether the statement was added to the identity's policies.
	 *
	 */
	readonly statementAdded: boolean;
	/**
	 * Dependable which allows depending on the policy change being applied
	 *
	 * @default - Required if `statementAdded` is true.
	 */
	readonly policyDependable?: IDependable;
}
declare class PrincipalPolicyFragment {
	readonly principalJson: {
		[key: string]: string[];
	};
	/**
	 * The conditions under which the policy is in effect.
	 * See [the IAM documentation](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_elements_condition.html).
	 */
	readonly conditions: Conditions;
	/**
	 *
	 * @param principalJson JSON of the "Principal" section in a policy statement
	 * @param conditions conditions that need to be applied to this policy
	 */
	constructor(principalJson: {
		[key: string]: string[];
	}, 
	/**
	 * The conditions under which the policy is in effect.
	 * See [the IAM documentation](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_elements_condition.html).
	 */
	conditions?: Conditions);
}
/**
 * Options for a service principal.
 */
export interface ServicePrincipalOpts {
	/**
	 * The region in which the service is operating.
	 *
	 * @default - the current Stack's region.
	 * @deprecated You should not need to set this. The stack's region is always correct.
	 */
	readonly region?: string;
	/**
	 * Additional conditions to add to the Service Principal
	 *
	 * @default - No conditions
	 */
	readonly conditions?: {
		[key: string]: any;
	};
}
declare class PolicyStatement {
	/**
	 * Creates a new PolicyStatement based on the object provided.
	 * This will accept an object created from the `.toJSON()` call
	 * @param obj the PolicyStatement in object form.
	 */
	static fromJson(obj: any): PolicyStatement;
	private readonly _action;
	private readonly _notAction;
	private readonly _principal;
	private readonly _notPrincipal;
	private readonly _resource;
	private readonly _notResource;
	private readonly _condition;
	private _sid?;
	private _effect;
	private principalConditionsJson?;
	private readonly _principals;
	private readonly _notPrincipals;
	private _frozen;
	constructor(props?: PolicyStatementProps);
	/**
	 * Statement ID for this statement
	 */
	get sid(): string | undefined;
	/**
	 * Set Statement ID for this statement
	 */
	set sid(sid: string | undefined);
	/**
	 * Whether to allow or deny the actions in this statement
	 */
	get effect(): Effect;
	/**
	 * Set effect for this statement
	 */
	set effect(effect: Effect);
	/**
	 * Specify allowed actions into the "Action" section of the policy statement.
	 *
	 * @see https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_elements_action.html
	 *
	 * @param actions actions that will be allowed.
	 */
	addActions(...actions: string[]): void;
	/**
	 * Explicitly allow all actions except the specified list of actions into the "NotAction" section
	 * of the policy document.
	 *
	 * @see https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_elements_notaction.html
	 *
	 * @param notActions actions that will be denied. All other actions will be permitted.
	 */
	addNotActions(...notActions: string[]): void;
	/**
	 * Indicates if this permission has a "Principal" section.
	 */
	get hasPrincipal(): boolean;
	/**
	 * Adds principals to the "Principal" section of a policy statement.
	 *
	 * @see https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_elements_principal.html
	 *
	 * @param principals IAM principals that will be added
	 */
	addPrincipals(...principals: IPrincipal[]): void;
	/**
	 * Specify principals that is not allowed or denied access to the "NotPrincipal" section of
	 * a policy statement.
	 *
	 * @see https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_elements_notprincipal.html
	 *
	 * @param notPrincipals IAM principals that will be denied access
	 */
	addNotPrincipals(...notPrincipals: IPrincipal[]): void;
	private validatePolicyPrincipal;
	/**
	 * Specify AWS account ID as the principal entity to the "Principal" section of a policy statement.
	 */
	addAwsAccountPrincipal(accountId: string): void;
	/**
	 * Specify a principal using the ARN  identifier of the principal.
	 * You cannot specify IAM groups and instance profiles as principals.
	 *
	 * @param arn ARN identifier of AWS account, IAM user, or IAM role (i.e. arn:aws:iam::123456789012:user/user-name)
	 */
	addArnPrincipal(arn: string): void;
	/**
	 * Adds a service principal to this policy statement.
	 *
	 * @param service the service name for which a service principal is requested (e.g: `s3.amazonaws.com`).
	 * @param opts    options for adding the service principal (such as specifying a principal in a different region)
	 */
	addServicePrincipal(service: string, opts?: ServicePrincipalOpts): void;
	/**
	 * Adds a federated identity provider such as Amazon Cognito to this policy statement.
	 *
	 * @param federated federated identity provider (i.e. 'cognito-identity.amazonaws.com')
	 * @param conditions The conditions under which the policy is in effect.
	 *   See [the IAM documentation](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_elements_condition.html).
	 */
	addFederatedPrincipal(federated: any, conditions: Conditions): void;
	/**
	 * Adds an AWS account root user principal to this policy statement
	 */
	addAccountRootPrincipal(): void;
	/**
	 * Adds a canonical user ID principal to this policy document
	 *
	 * @param canonicalUserId unique identifier assigned by AWS for every account
	 */
	addCanonicalUserPrincipal(canonicalUserId: string): void;
	/**
	 * Adds all identities in all accounts ("*") to this policy statement
	 */
	addAnyPrincipal(): void;
	/**
	 * Specify resources that this policy statement applies into the "Resource" section of
	 * this policy statement.
	 *
	 * @see https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_elements_resource.html
	 *
	 * @param arns Amazon Resource Names (ARNs) of the resources that this policy statement applies to
	 */
	addResources(...arns: string[]): void;
	/**
	 * Specify resources that this policy statement will not apply to in the "NotResource" section
	 * of this policy statement. All resources except the specified list will be matched.
	 *
	 * @see https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_elements_notresource.html
	 *
	 * @param arns Amazon Resource Names (ARNs) of the resources that this policy statement does not apply to
	 */
	addNotResources(...arns: string[]): void;
	/**
	 * Adds a ``"*"`` resource to this statement.
	 */
	addAllResources(): void;
	/**
	 * Indicates if this permission has at least one resource associated with it.
	 */
	get hasResource(): boolean;
	/**
	 * Add a condition to the Policy
	 *
	 * If multiple calls are made to add a condition with the same operator and field, only
	 * the last one wins. For example:
	 *
	 * ```ts
	 * declare const stmt: iam.PolicyStatement;
	 *
	 * stmt.addCondition('StringEquals', { 'aws:SomeField': '1' });
	 * stmt.addCondition('StringEquals', { 'aws:SomeField': '2' });
	 * ```
	 *
	 * Will end up with the single condition `StringEquals: { 'aws:SomeField': '2' }`.
	 *
	 * If you meant to add a condition to say that the field can be *either* `1` or `2`, write
	 * this:
	 *
	 * ```ts
	 * declare const stmt: iam.PolicyStatement;
	 *
	 * stmt.addCondition('StringEquals', { 'aws:SomeField': ['1', '2'] });
	 * ```
	 */
	addCondition(key: string, value: Condition): void;
	/**
	 * Add multiple conditions to the Policy
	 *
	 * See the `addCondition` function for a caveat on calling this method multiple times.
	 */
	addConditions(conditions: Conditions): void;
	/**
	 * Add a condition that limits to a given account
	 *
	 * This method can only be called once: subsequent calls will overwrite earlier calls.
	 */
	addAccountCondition(accountId: string): void;
	/**
	 * Create a new `PolicyStatement` with the same exact properties
	 * as this one, except for the overrides
	 */
	copy(overrides?: PolicyStatementProps): PolicyStatement;
	/**
	 * JSON-ify the policy statement
	 *
	 * Used when JSON.stringify() is called
	 */
	toStatementJson(): any;
	/**
	 * String representation of this policy statement
	 */
	toString(): string;
	/**
	 * JSON-ify the statement
	 *
	 * Used when JSON.stringify() is called
	 */
	toJSON(): any;
	/**
	 * Add a principal's conditions
	 *
	 * For convenience, principals have been modeled as both a principal
	 * and a set of conditions. This makes it possible to have a single
	 * object represent e.g. an "SNS Topic" (SNS service principal + aws:SourcArn
	 * condition) or an Organization member (* + aws:OrgId condition).
	 *
	 * However, when using multiple principals in the same policy statement,
	 * they must all have the same conditions or the OR samentics
	 * implied by a list of principals cannot be guaranteed (user needs to
	 * add multiple statements in that case).
	 */
	private addPrincipalConditions;
	/**
	 * Validate that the policy statement satisfies base requirements for a policy.
	 *
	 * @returns An array of validation error messages, or an empty array if the statement is valid.
	 */
	validateForAnyPolicy(): string[];
	/**
	 * Validate that the policy statement satisfies all requirements for a resource-based policy.
	 *
	 * @returns An array of validation error messages, or an empty array if the statement is valid.
	 */
	validateForResourcePolicy(): string[];
	/**
	 * Validate that the policy statement satisfies all requirements for an identity-based policy.
	 *
	 * @returns An array of validation error messages, or an empty array if the statement is valid.
	 */
	validateForIdentityPolicy(): string[];
	/**
	 * The Actions added to this statement
	 */
	get actions(): string[];
	/**
	 * The NotActions added to this statement
	 */
	get notActions(): string[];
	/**
	 * The Principals added to this statement
	 */
	get principals(): IPrincipal[];
	/**
	 * The NotPrincipals added to this statement
	 */
	get notPrincipals(): IPrincipal[];
	/**
	 * The Resources added to this statement
	 */
	get resources(): string[];
	/**
	 * The NotResources added to this statement
	 */
	get notResources(): string[];
	/**
	 * The conditions added to this statement
	 */
	get conditions(): any;
	/**
	 * Make the PolicyStatement immutable
	 *
	 * After calling this, any of the `addXxx()` methods will throw an exception.
	 *
	 * Libraries that lazily generate statement bodies can override this method to
	 * fill the actual PolicyStatement fields. Be aware that this method may be called
	 * multiple times.
	 */
	freeze(): PolicyStatement;
	/**
	 * Whether the PolicyStatement has been frozen
	 *
	 * The statement object is frozen when `freeze()` is called.
	 */
	get frozen(): boolean;
	/**
	 * Estimate the size of this policy statement
	 *
	 * By necessity, this will not be accurate. We'll do our best to overestimate
	 * so we won't have nasty surprises.
	 *
	 * @internal
	 */
	_estimateSize(options: EstimateSizeOptions): number;
	/**
	 * Throw an exception when the object is frozen
	 */
	private assertNotFrozen;
}
declare enum Effect {
	/**
	 * Allows access to a resource in an IAM policy statement. By default, access to resources are denied.
	 */
	ALLOW = "Allow",
	/**
	 * Explicitly deny access to a resource. By default, all requests are denied implicitly.
	 *
	 * @see https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_evaluation-logic.html
	 */
	DENY = "Deny"
}
/**
 * Condition for when an IAM policy is in effect. Maps from the keys in a request's context to
 * a string value or array of string values. See the Conditions interface for more details.
 */
export declare type Condition = unknown;
/**
 * Conditions for when an IAM Policy is in effect, specified in the following structure:
 *
 * `{ "Operator": { "keyInRequestContext": "value" } }`
 *
 * The value can be either a single string value or an array of string values.
 *
 * For more information, including which operators are supported, see [the IAM
 * documentation](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_elements_condition.html).
 */
export declare type Conditions = Record<string, Condition>;
/**
 * Interface for creating a policy statement
 */
export interface PolicyStatementProps {
	/**
	 * The Sid (statement ID) is an optional identifier that you provide for the
	 * policy statement. You can assign a Sid value to each statement in a
	 * statement array. In services that let you specify an ID element, such as
	 * SQS and SNS, the Sid value is just a sub-ID of the policy document's ID. In
	 * IAM, the Sid value must be unique within a JSON policy.
	 *
	 * @default - no sid
	 */
	readonly sid?: string;
	/**
	 * List of actions to add to the statement
	 *
	 * @default - no actions
	 */
	readonly actions?: string[];
	/**
	 * List of not actions to add to the statement
	 *
	 * @default - no not-actions
	 */
	readonly notActions?: string[];
	/**
	 * List of principals to add to the statement
	 *
	 * @default - no principals
	 */
	readonly principals?: IPrincipal[];
	/**
	 * List of not principals to add to the statement
	 *
	 * @default - no not principals
	 */
	readonly notPrincipals?: IPrincipal[];
	/**
	 * Resource ARNs to add to the statement
	 *
	 * @default - no resources
	 */
	readonly resources?: string[];
	/**
	 * NotResource ARNs to add to the statement
	 *
	 * @default - no not-resources
	 */
	readonly notResources?: string[];
	/**
	 * Conditions to add to the statement
	 *
	 * @default - no condition
	 */
	readonly conditions?: {
		[key: string]: any;
	};
	/**
	 * Whether to allow or deny the actions in this statement
	 *
	 * @default Effect.ALLOW
	 */
	readonly effect?: Effect;
}
/**
 * Options for _estimateSize
 *
 * These can optionally come from context, but it's too expensive to look
 * them up every time so we bundle them into a struct first.
 *
 * @internal
 */
export interface EstimateSizeOptions {
	/**
	 * Estimated size of an unresolved ARN
	 */
	readonly arnEstimate: number;
	/**
	 * Estimated size of an unresolved action
	 */
	readonly actionEstimate: number;
}
/**
 * Basic options for a grant operation
 *
 */
export interface CommonGrantOptions {
	/**
	 * The principal to grant to
	 *
	 * @default if principal is undefined, no work is done.
	 */
	readonly grantee: IGrantable;
	/**
	 * The actions to grant
	 */
	readonly actions: string[];
	/**
	 * The resource ARNs to grant to
	 */
	readonly resourceArns: string[];
}
/**
 * Options for a grant operation
 *
 */
export interface GrantWithResourceOptions extends CommonGrantOptions {
	/**
	 * The resource with a resource policy
	 *
	 * The statement will be added to the resource policy if it couldn't be
	 * added to the principal policy.
	 */
	readonly resource: IResourceWithPolicy;
	/**
	 * When referring to the resource in a resource policy, use this as ARN.
	 *
	 * (Depending on the resource type, this needs to be '*' in a resource policy).
	 *
	 * @default Same as regular resource ARNs
	 */
	readonly resourceSelfArns?: string[];
}
/**
 * Options for a grant operation that only applies to principals
 *
 */
export interface GrantOnPrincipalOptions extends CommonGrantOptions {
	/**
	 * Construct to report warnings on in case grant could not be registered
	 *
	 * @default - the construct in which this construct is defined
	 */
	readonly scope?: IConstruct;
}
/**
 * Options for a grant operation to both identity and resource
 *
 */
export interface GrantOnPrincipalAndResourceOptions extends CommonGrantOptions {
	/**
	 * The resource with a resource policy
	 *
	 * The statement will always be added to the resource policy.
	 */
	readonly resource: IResourceWithPolicy;
	/**
	 * When referring to the resource in a resource policy, use this as ARN.
	 *
	 * (Depending on the resource type, this needs to be '*' in a resource policy).
	 *
	 * @default Same as regular resource ARNs
	 */
	readonly resourceSelfArns?: string[];
	/**
	 * The principal to use in the statement for the resource policy.
	 *
	 * @default - the principal of the grantee will be used
	 */
	readonly resourcePolicyPrincipal?: IPrincipal;
}
declare class Grant implements IDependable {
	/**
	 * Grant the given permissions to the principal
	 *
	 * The permissions will be added to the principal policy primarily, falling
	 * back to the resource policy if necessary. The permissions must be granted
	 * somewhere.
	 *
	 * - Trying to grant permissions to a principal that does not admit adding to
	 *   the principal policy while not providing a resource with a resource policy
	 *   is an error.
	 * - Trying to grant permissions to an absent principal (possible in the
	 *   case of imported resources) leads to a warning being added to the
	 *   resource construct.
	 */
	static addToPrincipalOrResource(options: GrantWithResourceOptions): Grant;
	/**
	 * Try to grant the given permissions to the given principal
	 *
	 * Absence of a principal leads to a warning, but failing to add
	 * the permissions to a present principal is not an error.
	 */
	static addToPrincipal(options: GrantOnPrincipalOptions): Grant;
	/**
	 * Add a grant both on the principal and on the resource
	 *
	 * As long as any principal is given, granting on the principal may fail (in
	 * case of a non-identity principal), but granting on the resource will
	 * never fail.
	 *
	 * Statement will be the resource statement.
	 */
	static addToPrincipalAndResource(options: GrantOnPrincipalAndResourceOptions): Grant;
	/**
	 * Returns a "no-op" `Grant` object which represents a "dropped grant".
	 *
	 * This can be used for e.g. imported resources where you may not be able to modify
	 * the resource's policy or some underlying policy which you don't know about.
	 *
	 * @param grantee The intended grantee
	 * @param _intent The user's intent (will be ignored at the moment)
	 */
	static drop(grantee: IGrantable, _intent: string): Grant;
	/**
	 * The statement that was added to the principal's policy
	 *
	 * Can be accessed to (e.g.) add additional conditions to the statement.
	 */
	readonly principalStatement?: PolicyStatement;
	/**
	 * The statement that was added to the resource policy
	 *
	 * Can be accessed to (e.g.) add additional conditions to the statement.
	 */
	readonly resourceStatement?: PolicyStatement;
	/**
	 * The options originally used to set this result
	 *
	 * Private member doubles as a way to make it impossible for an object literal to
	 * be structurally the same as this class.
	 */
	private readonly options;
	private constructor();
	/**
	 * Whether the grant operation was successful
	 */
	get success(): boolean;
	/**
	 * Throw an error if this grant wasn't successful
	 */
	assertSuccess(): void;
	/**
	 * Make sure this grant is applied before the given constructs are deployed
	 *
	 * The same as construct.node.addDependency(grant), but slightly nicer to read.
	 */
	applyBefore(...constructs: IConstruct[]): void;
}
/**
 * A resource with a resource policy that can be added to
 */
export interface IResourceWithPolicy extends cdk.IResource {
	/**
	 * Add a statement to the resource's resource policy
	 */
	addToResourcePolicy(statement: PolicyStatement): AddToResourcePolicyResult;
}
/**
 * Result of calling addToResourcePolicy
 */
export interface AddToResourcePolicyResult {
	/**
	 * Whether the statement was added
	 */
	readonly statementAdded: boolean;
	/**
	 * Dependable which allows depending on the policy change being applied
	 *
	 * @default - If `statementAdded` is true, the resource object itself.
	 * Otherwise, no dependable.
	 */
	readonly policyDependable?: IDependable;
}
/**
 * A KMS Key alias.
 * An alias can be used in all places that expect a key.
 */
export interface IAlias extends IKey {
	/**
	 * The name of the alias.
	 *
	 * @attribute
	 */
	readonly aliasName: string;
	/**
	 * The Key to which the Alias refers.
	 *
	 * @attribute
	 */
	readonly aliasTargetKey: IKey;
}
/**
 * Construction properties for a KMS Key Alias object.
 */
export interface AliasProps {
	/**
	 * The name of the alias. The name must start with alias followed by a
	 * forward slash, such as alias/. You can't specify aliases that begin with
	 * alias/AWS. These aliases are reserved.
	 */
	readonly aliasName: string;
	/**
	 * The ID of the key for which you are creating the alias. Specify the key's
	 * globally unique identifier or Amazon Resource Name (ARN). You can't
	 * specify another alias.
	 */
	readonly targetKey: IKey;
	/**
	 * Policy to apply when the alias is removed from this stack.
	 *
	 * @default - The alias will be deleted
	 */
	readonly removalPolicy?: RemovalPolicy;
}
declare abstract class AliasBase extends Resource implements IAlias {
	abstract readonly aliasName: string;
	abstract readonly aliasTargetKey: IKey;
	get keyArn(): string;
	get keyId(): string;
	addAlias(alias: string): Alias;
	addToResourcePolicy(statement: iam.PolicyStatement, allowNoOp?: boolean): iam.AddToResourcePolicyResult;
	grant(grantee: iam.IGrantable, ...actions: string[]): iam.Grant;
	grantDecrypt(grantee: iam.IGrantable): iam.Grant;
	grantEncrypt(grantee: iam.IGrantable): iam.Grant;
	grantEncryptDecrypt(grantee: iam.IGrantable): iam.Grant;
}
/**
 * Properties of a reference to an existing KMS Alias
 */
export interface AliasAttributes {
	/**
	 * Specifies the alias name. This value must begin with alias/ followed by a name (i.e. alias/ExampleAlias)
	 */
	readonly aliasName: string;
	/**
	 * The customer master key (CMK) to which the Alias refers.
	 */
	readonly aliasTargetKey: IKey;
}
declare class Alias extends AliasBase {
	/**
	 * Import an existing KMS Alias defined outside the CDK app.
	 *
	 * @param scope The parent creating construct (usually `this`).
	 * @param id The construct's name.
	 * @param attrs the properties of the referenced KMS Alias
	 */
	static fromAliasAttributes(scope: Construct, id: string, attrs: AliasAttributes): IAlias;
	/**
	 * Import an existing KMS Alias defined outside the CDK app, by the alias name. This method should be used
	 * instead of 'fromAliasAttributes' when the underlying KMS Key ARN is not available.
	 * This Alias will not have a direct reference to the KMS Key, so addAlias and grant* methods are not supported.
	 *
	 * @param scope The parent creating construct (usually `this`).
	 * @param id The construct's name.
	 * @param aliasName The full name of the KMS Alias (e.g., 'alias/aws/s3', 'alias/myKeyAlias').
	 */
	static fromAliasName(scope: Construct, id: string, aliasName: string): IAlias;
	readonly aliasName: string;
	readonly aliasTargetKey: IKey;
	constructor(scope: Construct, id: string, props: AliasProps);
	protected generatePhysicalName(): string;
}
/**
 * A KMS Key, either managed by this CDK app, or imported.
 */
export interface IKey extends IResource {
	/**
	 * The ARN of the key.
	 *
	 * @attribute
	 */
	readonly keyArn: string;
	/**
	 * The ID of the key
	 * (the part that looks something like: 1234abcd-12ab-34cd-56ef-1234567890ab).
	 *
	 * @attribute
	 */
	readonly keyId: string;
	/**
	 * Defines a new alias for the key.
	 */
	addAlias(alias: string): Alias;
	/**
	 * Adds a statement to the KMS key resource policy.
	 * @param statement The policy statement to add
	 * @param allowNoOp If this is set to `false` and there is no policy
	 * defined (i.e. external key), the operation will fail. Otherwise, it will
	 * no-op.
	 */
	addToResourcePolicy(statement: iam.PolicyStatement, allowNoOp?: boolean): iam.AddToResourcePolicyResult;
	/**
	 * Grant the indicated permissions on this key to the given principal
	 */
	grant(grantee: iam.IGrantable, ...actions: string[]): iam.Grant;
	/**
	 * Grant decryption permissions using this key to the given principal
	 */
	grantDecrypt(grantee: iam.IGrantable): iam.Grant;
	/**
	 * Grant encryption permissions using this key to the given principal
	 */
	grantEncrypt(grantee: iam.IGrantable): iam.Grant;
	/**
	 * Grant encryption and decryption permissions using this key to the given principal
	 */
	grantEncryptDecrypt(grantee: iam.IGrantable): iam.Grant;
}
/**
 * Represents an SQS queue
 */
export interface IQueue extends IResource {
	/**
	 * The ARN of this queue
	 * @attribute
	 */
	readonly queueArn: string;
	/**
	 * The URL of this queue
	 * @attribute
	 */
	readonly queueUrl: string;
	/**
	 * The name of this queue
	 * @attribute
	 */
	readonly queueName: string;
	/**
	 * If this queue is server-side encrypted, this is the KMS encryption key.
	 */
	readonly encryptionMasterKey?: kms.IKey;
	/**
	 * Whether this queue is an Amazon SQS FIFO queue. If false, this is a standard queue.
	 */
	readonly fifo: boolean;
	/**
	 * Adds a statement to the IAM resource policy associated with this queue.
	 *
	 * If this queue was created in this stack (`new Queue`), a queue policy
	 * will be automatically created upon the first call to `addToPolicy`. If
	 * the queue is imported (`Queue.import`), then this is a no-op.
	 */
	addToResourcePolicy(statement: iam.PolicyStatement): iam.AddToResourcePolicyResult;
	/**
	 * Grant permissions to consume messages from a queue
	 *
	 * This will grant the following permissions:
	 *
	 *   - sqs:ChangeMessageVisibility
	 *   - sqs:DeleteMessage
	 *   - sqs:ReceiveMessage
	 *   - sqs:GetQueueAttributes
	 *   - sqs:GetQueueUrl
	 *
	 * @param grantee Principal to grant consume rights to
	 */
	grantConsumeMessages(grantee: iam.IGrantable): iam.Grant;
	/**
	 * Grant access to send messages to a queue to the given identity.
	 *
	 * This will grant the following permissions:
	 *
	 *  - sqs:SendMessage
	 *  - sqs:GetQueueAttributes
	 *  - sqs:GetQueueUrl
	 *
	 * @param grantee Principal to grant send rights to
	 */
	grantSendMessages(grantee: iam.IGrantable): iam.Grant;
	/**
	 * Grant an IAM principal permissions to purge all messages from the queue.
	 *
	 * This will grant the following permissions:
	 *
	 *  - sqs:PurgeQueue
	 *  - sqs:GetQueueAttributes
	 *  - sqs:GetQueueUrl
	 *
	 * @param grantee Principal to grant send rights to
	 */
	grantPurge(grantee: iam.IGrantable): iam.Grant;
	/**
	 * Grant the actions defined in queueActions to the identity Principal given
	 * on this SQS queue resource.
	 *
	 * @param grantee Principal to grant right to
	 * @param queueActions The actions to grant
	 */
	grant(grantee: iam.IGrantable, ...queueActions: string[]): iam.Grant;
}
declare abstract class QueueBase extends Resource implements IQueue {
	/**
	 * The ARN of this queue
	 */
	abstract readonly queueArn: string;
	/**
	 * The URL of this queue
	 */
	abstract readonly queueUrl: string;
	/**
	 * The name of this queue
	 */
	abstract readonly queueName: string;
	/**
	 * If this queue is server-side encrypted, this is the KMS encryption key.
	 */
	abstract readonly encryptionMasterKey?: kms.IKey;
	/**
	 * Whether this queue is an Amazon SQS FIFO queue. If false, this is a standard queue.
	 */
	abstract readonly fifo: boolean;
	/**
	 * Controls automatic creation of policy objects.
	 *
	 * Set by subclasses.
	 */
	protected abstract readonly autoCreatePolicy: boolean;
	private policy?;
	constructor(scope: Construct, id: string, props?: ResourceProps);
	/**
	 * Adds a statement to the IAM resource policy associated with this queue.
	 *
	 * If this queue was created in this stack (`new Queue`), a queue policy
	 * will be automatically created upon the first call to `addToPolicy`. If
	 * the queue is imported (`Queue.import`), then this is a no-op.
	 */
	addToResourcePolicy(statement: iam.PolicyStatement): iam.AddToResourcePolicyResult;
	/**
	 * Grant permissions to consume messages from a queue
	 *
	 * This will grant the following permissions:
	 *
	 *   - sqs:ChangeMessageVisibility
	 *   - sqs:DeleteMessage
	 *   - sqs:ReceiveMessage
	 *   - sqs:GetQueueAttributes
	 *   - sqs:GetQueueUrl
	 *
	 * @param grantee Principal to grant consume rights to
	 */
	grantConsumeMessages(grantee: iam.IGrantable): iam.Grant;
	/**
	 * Grant access to send messages to a queue to the given identity.
	 *
	 * This will grant the following permissions:
	 *
	 *  - sqs:SendMessage
	 *  - sqs:GetQueueAttributes
	 *  - sqs:GetQueueUrl
	 *
	 * @param grantee Principal to grant send rights to
	 */
	grantSendMessages(grantee: iam.IGrantable): iam.Grant;
	/**
	 * Grant an IAM principal permissions to purge all messages from the queue.
	 *
	 * This will grant the following permissions:
	 *
	 *  - sqs:PurgeQueue
	 *  - sqs:GetQueueAttributes
	 *  - sqs:GetQueueUrl
	 *
	 * @param grantee Principal to grant send rights to
	 */
	grantPurge(grantee: iam.IGrantable): iam.Grant;
	/**
	 * Grant the actions defined in queueActions to the identity Principal given
	 * on this SQS queue resource.
	 *
	 * @param grantee Principal to grant right to
	 * @param actions The actions to grant
	 */
	grant(grantee: iam.IGrantable, ...actions: string[]): iam.Grant;
}
/**
 * Reference to a queue
 */
export interface QueueAttributes {
	/**
	 * The ARN of the queue.
	 */
	readonly queueArn: string;
	/**
	 * The URL of the queue.
	 * @see https://docs.aws.amazon.com/sdk-for-net/v2/developer-guide/QueueURL.html
	 *
	 * @default - 'https://sqs.<region-endpoint>/<account-ID>/<queue-name>'
	 */
	readonly queueUrl?: string;
	/**
	 * The name of the queue.
	 * @default if queue name is not specified, the name will be derived from the queue ARN
	 */
	readonly queueName?: string;
	/**
	 * KMS encryption key, if this queue is server-side encrypted by a KMS key.
	 *
	 * @default - None
	 */
	readonly keyArn?: string;
	/**
	 * Whether this queue is an Amazon SQS FIFO queue. If false, this is a standard queue.
	 *
	 * In case of a FIFO queue which is imported from a token, this value has to be explicitly set to true.
	 *
	 * @default - if fifo is not specified, the property will be determined based on the queue name (not possible for FIFO queues imported from a token)
	 */
	readonly fifo?: boolean;
}
/**
 * Properties for creating a new Queue
 */
export interface QueueProps {
	/**
	 * A name for the queue.
	 *
	 * If specified and this is a FIFO queue, must end in the string '.fifo'.
	 *
	 * @default CloudFormation-generated name
	 */
	readonly queueName?: string;
	/**
	 * The number of seconds that Amazon SQS retains a message.
	 *
	 * You can specify an integer value from 60 seconds (1 minute) to 1209600
	 * seconds (14 days). The default value is 345600 seconds (4 days).
	 *
	 * @default Duration.days(4)
	 */
	readonly retentionPeriod?: Duration;
	/**
	 * The time in seconds that the delivery of all messages in the queue is delayed.
	 *
	 * You can specify an integer value of 0 to 900 (15 minutes). The default
	 * value is 0.
	 *
	 * @default 0
	 */
	readonly deliveryDelay?: Duration;
	/**
	 * The limit of how many bytes that a message can contain before Amazon SQS rejects it.
	 *
	 * You can specify an integer value from 1024 bytes (1 KiB) to 262144 bytes
	 * (256 KiB). The default value is 262144 (256 KiB).
	 *
	 * @default 256KiB
	 */
	readonly maxMessageSizeBytes?: number;
	/**
	 * Default wait time for ReceiveMessage calls.
	 *
	 * Does not wait if set to 0, otherwise waits this amount of seconds
	 * by default for messages to arrive.
	 *
	 * For more information, see Amazon SQS Long Poll.
	 *
	 *  @default 0
	 */
	readonly receiveMessageWaitTime?: Duration;
	/**
	 * Timeout of processing a single message.
	 *
	 * After dequeuing, the processor has this much time to handle the message
	 * and delete it from the queue before it becomes visible again for dequeueing
	 * by another processor.
	 *
	 * Values must be from 0 to 43200 seconds (12 hours). If you don't specify
	 * a value, AWS CloudFormation uses the default value of 30 seconds.
	 *
	 * @default Duration.seconds(30)
	 */
	readonly visibilityTimeout?: Duration;
	/**
	 * Send messages to this queue if they were unsuccessfully dequeued a number of times.
	 *
	 * @default no dead-letter queue
	 */
	readonly deadLetterQueue?: DeadLetterQueue;
	/**
	 * Whether the contents of the queue are encrypted, and by what type of key.
	 *
	 * Be aware that encryption is not available in all regions, please see the docs
	 * for current availability details.
	 *
	 * @default SQS_MANAGED (SSE-SQS) for newly created queues
	 */
	readonly encryption?: QueueEncryption;
	/**
	 * External KMS key to use for queue encryption.
	 *
	 * Individual messages will be encrypted using data keys. The data keys in
	 * turn will be encrypted using this key, and reused for a maximum of
	 * `dataKeyReuseSecs` seconds.
	 *
	 * If the 'encryptionMasterKey' property is set, 'encryption' type will be
	 * implicitly set to "KMS".
	 *
	 * @default If encryption is set to KMS and not specified, a key will be created.
	 */
	readonly encryptionMasterKey?: kms.IKey;
	/**
	 * The length of time that Amazon SQS reuses a data key before calling KMS again.
	 *
	 * The value must be an integer between 60 (1 minute) and 86,400 (24
	 * hours). The default is 300 (5 minutes).
	 *
	 * @default Duration.minutes(5)
	 */
	readonly dataKeyReuse?: Duration;
	/**
	 * Whether this a first-in-first-out (FIFO) queue.
	 *
	 * @default false, unless queueName ends in '.fifo' or 'contentBasedDeduplication' is true.
	 */
	readonly fifo?: boolean;
	/**
	 * Specifies whether to enable content-based deduplication.
	 *
	 * During the deduplication interval (5 minutes), Amazon SQS treats
	 * messages that are sent with identical content (excluding attributes) as
	 * duplicates and delivers only one copy of the message.
	 *
	 * If you don't enable content-based deduplication and you want to deduplicate
	 * messages, provide an explicit deduplication ID in your SendMessage() call.
	 *
	 * (Only applies to FIFO queues.)
	 *
	 * @default false
	 */
	readonly contentBasedDeduplication?: boolean;
	/**
	 * For high throughput for FIFO queues, specifies whether message deduplication
	 * occurs at the message group or queue level.
	 *
	 * (Only applies to FIFO queues.)
	 *
	 * @default DeduplicationScope.QUEUE
	 */
	readonly deduplicationScope?: DeduplicationScope;
	/**
	 * For high throughput for FIFO queues, specifies whether the FIFO queue
	 * throughput quota applies to the entire queue or per message group.
	 *
	 * (Only applies to FIFO queues.)
	 *
	 * @default FifoThroughputLimit.PER_QUEUE
	 */
	readonly fifoThroughputLimit?: FifoThroughputLimit;
	/**
	 * Policy to apply when the queue is removed from the stack
	 *
	 * Even though queues are technically stateful, their contents are transient and it
	 * is common to add and remove Queues while rearchitecting your application. The
	 * default is therefore `DESTROY`. Change it to `RETAIN` if the messages are so
	 * valuable that accidentally losing them would be unacceptable.
	 *
	 * @default RemovalPolicy.DESTROY
	 */
	readonly removalPolicy?: RemovalPolicy;
	/**
	 * Enforce encryption of data in transit.
	 * @see https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-security-best-practices.html#enforce-encryption-data-in-transit
	 *
	 * @default false
	 */
	readonly enforceSSL?: boolean;
}
/**
 * Dead letter queue settings
 */
export interface DeadLetterQueue {
	/**
	 * The dead-letter queue to which Amazon SQS moves messages after the value of maxReceiveCount is exceeded.
	 */
	readonly queue: IQueue;
	/**
	 * The number of times a message can be unsuccesfully dequeued before being moved to the dead-letter queue.
	 */
	readonly maxReceiveCount: number;
}
declare enum QueueEncryption {
	/**
	 * Messages in the queue are not encrypted
	 */
	UNENCRYPTED = "NONE",
	/**
	 * Server-side KMS encryption with a KMS key managed by SQS.
	 */
	KMS_MANAGED = "KMS_MANAGED",
	/**
	 * Server-side encryption with a KMS key managed by the user.
	 *
	 * If `encryptionKey` is specified, this key will be used, otherwise, one will be defined.
	 */
	KMS = "KMS",
	/**
	 * Server-side encryption key managed by SQS (SSE-SQS).
	 *
	 * To learn more about SSE-SQS on Amazon SQS, please visit the
	 * [Amazon SQS documentation](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-server-side-encryption.html).
	 */
	SQS_MANAGED = "SQS_MANAGED"
}
declare enum DeduplicationScope {
	/**
	 * Deduplication occurs at the message group level
	 */
	MESSAGE_GROUP = "messageGroup",
	/**
	 * Deduplication occurs at the message queue level
	 */
	QUEUE = "queue"
}
declare enum FifoThroughputLimit {
	/**
	 * Throughput quota applies per queue
	 */
	PER_QUEUE = "perQueue",
	/**
	 * Throughput quota applies per message group id
	 */
	PER_MESSAGE_GROUP_ID = "perMessageGroupId"
}
declare class Queue extends QueueBase {
	/**
	 * Import an existing SQS queue provided an ARN
	 *
	 * @param scope The parent creating construct
	 * @param id The construct's name
	 * @param queueArn queue ARN (i.e. arn:aws:sqs:us-east-2:444455556666:queue1)
	 */
	static fromQueueArn(scope: Construct, id: string, queueArn: string): IQueue;
	/**
	 * Import an existing queue
	 */
	static fromQueueAttributes(scope: Construct, id: string, attrs: QueueAttributes): IQueue;
	/**
	 * The ARN of this queue
	 */
	readonly queueArn: string;
	/**
	 * The name of this queue
	 */
	readonly queueName: string;
	/**
	 * The URL of this queue
	 */
	readonly queueUrl: string;
	/**
	 * If this queue is encrypted, this is the KMS key.
	 */
	readonly encryptionMasterKey?: kms.IKey;
	/**
	 * Whether this queue is an Amazon SQS FIFO queue. If false, this is a standard queue.
	 */
	readonly fifo: boolean;
	/**
	 * If this queue is configured with a dead-letter queue, this is the dead-letter queue settings.
	 */
	readonly deadLetterQueue?: DeadLetterQueue;
	protected readonly autoCreatePolicy = true;
	constructor(scope: Construct, id: string, props?: QueueProps);
	/**
	 * Look at the props, see if the FIFO props agree, and return the correct subset of props
	 */
	private determineFifoProps;
	/**
	 * Adds an iam statement to enforce encryption of data in transit.
	 */
	private enforceSSLStatement;
}
/**
 * Interface for Alarm Rule.
 */
export interface IAlarmRule {
	/**
	 * serialized representation of Alarm Rule to be used when building the Composite Alarm resource.
	 */
	renderAlarmRule(): string;
}
/**
 * Represents a CloudWatch Alarm
 */
export interface IAlarm extends IAlarmRule, IResource {
	/**
	 * Alarm ARN (i.e. arn:aws:cloudwatch:<region>:<account-id>:alarm:Foo)
	 *
	 * @attribute
	 */
	readonly alarmArn: string;
	/**
	 * Name of the alarm
	 *
	 * @attribute
	 */
	readonly alarmName: string;
}
declare abstract class AlarmBase extends Resource implements IAlarm {
	/**
	 * @attribute
	 */
	abstract readonly alarmArn: string;
	abstract readonly alarmName: string;
	protected alarmActionArns?: string[];
	protected insufficientDataActionArns?: string[];
	protected okActionArns?: string[];
	/**
	 * AlarmRule indicating ALARM state for Alarm.
	 */
	renderAlarmRule(): string;
	/**
	 * Trigger this action if the alarm fires
	 *
	 * Typically the ARN of an SNS topic or ARN of an AutoScaling policy.
	 */
	addAlarmAction(...actions: IAlarmAction[]): void;
	/**
	 * Trigger this action if there is insufficient data to evaluate the alarm
	 *
	 * Typically the ARN of an SNS topic or ARN of an AutoScaling policy.
	 */
	addInsufficientDataAction(...actions: IAlarmAction[]): void;
	/**
	 * Trigger this action if the alarm returns from breaching state into ok state
	 *
	 * Typically the ARN of an SNS topic or ARN of an AutoScaling policy.
	 */
	addOkAction(...actions: IAlarmAction[]): void;
}
/**
 * Interface for objects that can be the targets of CloudWatch alarm actions
 */
export interface IAlarmAction {
	/**
	 * Return the properties required to send alarm actions to this CloudWatch alarm.
	 *
	 * @param scope root Construct that allows creating new Constructs
	 * @param alarm CloudWatch alarm that the action will target
	 */
	bind(scope: Construct, alarm: IAlarm): AlarmActionConfig;
}
/**
 * Properties for an alarm action
 */
export interface AlarmActionConfig {
	/**
	 * Return the ARN that should be used for a CloudWatch Alarm action
	 */
	readonly alarmActionArn: string;
}
/**
 * Interface for metrics
 */
export interface IMetric {
	/**
	 * Any warnings related to this metric
	 *
	 * Should be attached to the consuming construct.
	 *
	 * @default - None
	 */
	readonly warnings?: string[];
	/**
	 * Inspect the details of the metric object
	 */
	toMetricConfig(): MetricConfig;
}
/**
 * Metric dimension
 *
 * @see https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cw-dimension.html
 *
 */
export interface Dimension {
	/**
	 * Name of the dimension
	 */
	readonly name: string;
	/**
	 * Value of the dimension
	 */
	readonly value: any;
}
declare enum Unit {
	/**
	 * Seconds
	 */
	SECONDS = "Seconds",
	/**
	 * Microseconds
	 */
	MICROSECONDS = "Microseconds",
	/**
	 * Milliseconds
	 */
	MILLISECONDS = "Milliseconds",
	/**
	 * Bytes
	 */
	BYTES = "Bytes",
	/**
	 * Kilobytes
	 */
	KILOBYTES = "Kilobytes",
	/**
	 * Megabytes
	 */
	MEGABYTES = "Megabytes",
	/**
	 * Gigabytes
	 */
	GIGABYTES = "Gigabytes",
	/**
	 * Terabytes
	 */
	TERABYTES = "Terabytes",
	/**
	 * Bits
	 */
	BITS = "Bits",
	/**
	 * Kilobits
	 */
	KILOBITS = "Kilobits",
	/**
	 * Megabits
	 */
	MEGABITS = "Megabits",
	/**
	 * Gigabits
	 */
	GIGABITS = "Gigabits",
	/**
	 * Terabits
	 */
	TERABITS = "Terabits",
	/**
	 * Percent
	 */
	PERCENT = "Percent",
	/**
	 * Count
	 */
	COUNT = "Count",
	/**
	 * Bytes/second (B/s)
	 */
	BYTES_PER_SECOND = "Bytes/Second",
	/**
	 * Kilobytes/second (kB/s)
	 */
	KILOBYTES_PER_SECOND = "Kilobytes/Second",
	/**
	 * Megabytes/second (MB/s)
	 */
	MEGABYTES_PER_SECOND = "Megabytes/Second",
	/**
	 * Gigabytes/second (GB/s)
	 */
	GIGABYTES_PER_SECOND = "Gigabytes/Second",
	/**
	 * Terabytes/second (TB/s)
	 */
	TERABYTES_PER_SECOND = "Terabytes/Second",
	/**
	 * Bits/second (b/s)
	 */
	BITS_PER_SECOND = "Bits/Second",
	/**
	 * Kilobits/second (kb/s)
	 */
	KILOBITS_PER_SECOND = "Kilobits/Second",
	/**
	 * Megabits/second (Mb/s)
	 */
	MEGABITS_PER_SECOND = "Megabits/Second",
	/**
	 * Gigabits/second (Gb/s)
	 */
	GIGABITS_PER_SECOND = "Gigabits/Second",
	/**
	 * Terabits/second (Tb/s)
	 */
	TERABITS_PER_SECOND = "Terabits/Second",
	/**
	 * Count/second
	 */
	COUNT_PER_SECOND = "Count/Second",
	/**
	 * None
	 */
	NONE = "None"
}
/**
 * Properties of a rendered metric
 */
export interface MetricConfig {
	/**
	 * In case the metric represents a query, the details of the query
	 *
	 * @default - None
	 */
	readonly metricStat?: MetricStatConfig;
	/**
	 * In case the metric is a math expression, the details of the math expression
	 *
	 * @default - None
	 */
	readonly mathExpression?: MetricExpressionConfig;
	/**
	 * Additional properties which will be rendered if the metric is used in a dashboard
	 *
	 * Examples are 'label' and 'color', but any key in here will be
	 * added to dashboard graphs.
	 *
	 * @default - None
	 */
	readonly renderingProperties?: Record<string, unknown>;
}
/**
 * Properties for a concrete metric
 *
 * NOTE: `unit` is no longer on this object since it is only used for `Alarms`, and doesn't mean what one
 * would expect it to mean there anyway. It is most likely to be misused.
 */
export interface MetricStatConfig {
	/**
	 * The dimensions to apply to the alarm
	 *
	 * @default []
	 */
	readonly dimensions?: Dimension[];
	/**
	 * Namespace of the metric
	 */
	readonly namespace: string;
	/**
	 * Name of the metric
	 */
	readonly metricName: string;
	/**
	 * How many seconds to aggregate over
	 */
	readonly period: Duration;
	/**
	 * Aggregation function to use (can be either simple or a percentile)
	 */
	readonly statistic: string;
	/**
	 * Unit used to filter the metric stream
	 *
	 * Only refer to datums emitted to the metric stream with the given unit and
	 * ignore all others. Only useful when datums are being emitted to the same
	 * metric stream under different units.
	 *
	 * This field has been renamed from plain `unit` to clearly communicate
	 * its purpose.
	 *
	 * @default - Refer to all metric datums
	 */
	readonly unitFilter?: Unit;
	/**
	 * Region which this metric comes from.
	 *
	 * @default Deployment region.
	 */
	readonly region?: string;
	/**
	 * Account which this metric comes from.
	 *
	 * @default Deployment account.
	 */
	readonly account?: string;
}
/**
 * Properties for a concrete metric
 */
export interface MetricExpressionConfig {
	/**
	 * Math expression for the metric.
	 */
	readonly expression: string;
	/**
	 * Metrics used in the math expression
	 */
	readonly usingMetrics: Record<string, IMetric>;
	/**
	 * How many seconds to aggregate over
	 */
	readonly period: number;
	/**
	 * Account to evaluate search expressions within.
	 *
	 * @default - Deployment account.
	 */
	readonly searchAccount?: string;
	/**
	 * Region to evaluate search expressions within.
	 *
	 * @default - Deployment region.
	 */
	readonly searchRegion?: string;
}
/**
 * Horizontal annotation to be added to a graph
 */
export interface HorizontalAnnotation {
	/**
	 * The value of the annotation
	 */
	readonly value: number;
	/**
	 * Label for the annotation
	 *
	 * @default - No label
	 */
	readonly label?: string;
	/**
	 * The hex color code, prefixed with '#' (e.g. '#00ff00'), to be used for the annotation.
	 * The `Color` class has a set of standard colors that can be used here.
	 *
	 * @default - Automatic color
	 */
	readonly color?: string;
	/**
	 * Add shading above or below the annotation
	 *
	 * @default No shading
	 */
	readonly fill?: Shading;
	/**
	 * Whether the annotation is visible
	 *
	 * @default true
	 */
	readonly visible?: boolean;
}
declare enum Shading {
	/**
	 * Don't add shading
	 */
	NONE = "none",
	/**
	 * Add shading above the annotation
	 */
	ABOVE = "above",
	/**
	 * Add shading below the annotation
	 */
	BELOW = "below"
}
export declare type DimensionHash = {
	[dim: string]: any;
};
export declare type DimensionsMap = {
	[dim: string]: string;
};
/**
 * Options shared by most methods accepting metric options
 */
export interface CommonMetricOptions {
	/**
	 * The period over which the specified statistic is applied.
	 *
	 * @default Duration.minutes(5)
	 */
	readonly period?: cdk.Duration;
	/**
	 * What function to use for aggregating.
	 *
	 * Can be one of the following:
	 *
	 * - "Minimum" | "min"
	 * - "Maximum" | "max"
	 * - "Average" | "avg"
	 * - "Sum" | "sum"
	 * - "SampleCount | "n"
	 * - "pNN.NN"
	 *
	 * @default Average
	 */
	readonly statistic?: string;
	/**
	 * Dimensions of the metric
	 *
	 * @default - No dimensions.
	 */
	readonly dimensionsMap?: DimensionsMap;
	/**
	 * Unit used to filter the metric stream
	 *
	 * Only refer to datums emitted to the metric stream with the given unit and
	 * ignore all others. Only useful when datums are being emitted to the same
	 * metric stream under different units.
	 *
	 * The default is to use all matric datums in the stream, regardless of unit,
	 * which is recommended in nearly all cases.
	 *
	 * CloudWatch does not honor this property for graphs.
	 *
	 * @default - All metric datums in the given metric stream
	 */
	readonly unit?: Unit;
	/**
	 * Label for this metric when added to a Graph in a Dashboard
	 *
	 * You can use [dynamic labels](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html)
	 * to show summary information about the entire displayed time series
	 * in the legend. For example, if you use:
	 *
	 * ```
	 * [max: ${MAX}] MyMetric
	 * ```
	 *
	 * As the metric label, the maximum value in the visible range will
	 * be shown next to the time series name in the graph's legend.
	 *
	 * @default - No label
	 */
	readonly label?: string;
	/**
	 * The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph.
	 * The `Color` class has a set of standard colors that can be used here.
	 * @default - Automatic color
	 */
	readonly color?: string;
	/**
	 * Account which this metric comes from.
	 *
	 * @default - Deployment account.
	 */
	readonly account?: string;
	/**
	 * Region which this metric comes from.
	 *
	 * @default - Deployment region.
	 */
	readonly region?: string;
}
/**
 * Properties for a metric
 */
export interface MetricProps extends CommonMetricOptions {
	/**
	 * Namespace of the metric.
	 */
	readonly namespace: string;
	/**
	 * Name of the metric.
	 */
	readonly metricName: string;
}
/**
 * Properties of a metric that can be changed
 */
export interface MetricOptions extends CommonMetricOptions {
}
declare class Metric implements IMetric {
	/**
	 * Grant permissions to the given identity to write metrics.
	 *
	 * @param grantee The IAM identity to give permissions to.
	 */
	static grantPutMetricData(grantee: iam.IGrantable): iam.Grant;
	/** Dimensions of this metric */
	readonly dimensions?: DimensionHash;
	/** Namespace of this metric */
	readonly namespace: string;
	/** Name of this metric */
	readonly metricName: string;
	/** Period of this metric */
	readonly period: cdk.Duration;
	/** Statistic of this metric */
	readonly statistic: string;
	/** Label for this metric when added to a Graph in a Dashboard */
	readonly label?: string;
	/** The hex color code used when this metric is rendered on a graph. */
	readonly color?: string;
	/** Unit of the metric. */
	readonly unit?: Unit;
	/** Account which this metric comes from */
	readonly account?: string;
	/** Region which this metric comes from. */
	readonly region?: string;
	/** Warnings attached to this metric. */
	readonly warnings?: string[];
	constructor(props: MetricProps);
	/**
	 * Return a copy of Metric `with` properties changed.
	 *
	 * All properties except namespace and metricName can be changed.
	 *
	 * @param props The set of properties to change.
	 */
	with(props: MetricOptions): Metric;
	/**
	 * Attach the metric object to the given construct scope
	 *
	 * Returns a Metric object that uses the account and region from the Stack
	 * the given construct is defined in. If the metric is subsequently used
	 * in a Dashboard or Alarm in a different Stack defined in a different
	 * account or region, the appropriate 'region' and 'account' fields
	 * will be added to it.
	 *
	 * If the scope we attach to is in an environment-agnostic stack,
	 * nothing is done and the same Metric object is returned.
	 */
	attachTo(scope: IConstruct): Metric;
	toMetricConfig(): MetricConfig;
	/**
	 * Make a new Alarm for this metric
	 *
	 * Combines both properties that may adjust the metric (aggregation) as well
	 * as alarm properties.
	 */
	createAlarm(scope: Construct, id: string, props: CreateAlarmOptions): Alarm;
	toString(): string;
	/**
	 * Return the dimensions of this Metric as a list of Dimension.
	 */
	private dimensionsAsList;
	private validateDimensions;
}
/**
 * Properties needed to make an alarm from a metric
 */
export interface CreateAlarmOptions {
	/**
	 * Name of the alarm
	 *
	 * @default Automatically generated name
	 */
	readonly alarmName?: string;
	/**
	 * Description for the alarm
	 *
	 * @default No description
	 */
	readonly alarmDescription?: string;
	/**
	 * Comparison to use to check if metric is breaching
	 *
	 * @default GreaterThanOrEqualToThreshold
	 */
	readonly comparisonOperator?: ComparisonOperator;
	/**
	 * The value against which the specified statistic is compared.
	 */
	readonly threshold: number;
	/**
	 * The number of periods over which data is compared to the specified threshold.
	 */
	readonly evaluationPeriods: number;
	/**
	 * Specifies whether to evaluate the data and potentially change the alarm state if there are too few data points to be statistically significant.
	 *
	 * Used only for alarms that are based on percentiles.
	 *
	 * @default - Not configured.
	 */
	readonly evaluateLowSampleCountPercentile?: string;
	/**
	 * Sets how this alarm is to handle missing data points.
	 *
	 * @default TreatMissingData.Missing
	 */
	readonly treatMissingData?: TreatMissingData;
	/**
	 * Whether the actions for this alarm are enabled
	 *
	 * @default true
	 */
	readonly actionsEnabled?: boolean;
	/**
	 * The number of datapoints that must be breaching to trigger the alarm. This is used only if you are setting an "M
	 * out of N" alarm. In that case, this value is the M. For more information, see Evaluating an Alarm in the Amazon
	 * CloudWatch User Guide.
	 *
	 * @default ``evaluationPeriods``
	 *
	 * @see https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/AlarmThatSendsEmail.html#alarm-evaluation
	 */
	readonly datapointsToAlarm?: number;
}
/**
 * Properties for Alarms
 */
export interface AlarmProps extends CreateAlarmOptions {
	/**
	 * The metric to add the alarm on
	 *
	 * Metric objects can be obtained from most resources, or you can construct
	 * custom Metric objects by instantiating one.
	 */
	readonly metric: IMetric;
}
declare enum ComparisonOperator {
	/**
	 * Specified statistic is greater than or equal to the threshold
	 */
	GREATER_THAN_OR_EQUAL_TO_THRESHOLD = "GreaterThanOrEqualToThreshold",
	/**
	 * Specified statistic is strictly greater than the threshold
	 */
	GREATER_THAN_THRESHOLD = "GreaterThanThreshold",
	/**
	 * Specified statistic is strictly less than the threshold
	 */
	LESS_THAN_THRESHOLD = "LessThanThreshold",
	/**
	 * Specified statistic is less than or equal to the threshold.
	 */
	LESS_THAN_OR_EQUAL_TO_THRESHOLD = "LessThanOrEqualToThreshold",
	/**
	 * Specified statistic is lower than or greater than the anomaly model band.
	 * Used only for alarms based on anomaly detection models
	 */
	LESS_THAN_LOWER_OR_GREATER_THAN_UPPER_THRESHOLD = "LessThanLowerOrGreaterThanUpperThreshold",
	/**
	 * Specified statistic is greater than the anomaly model band.
	 * Used only for alarms based on anomaly detection models
	 */
	GREATER_THAN_UPPER_THRESHOLD = "GreaterThanUpperThreshold",
	/**
	 * Specified statistic is lower than the anomaly model band.
	 * Used only for alarms based on anomaly detection models
	 */
	LESS_THAN_LOWER_THRESHOLD = "LessThanLowerThreshold"
}
declare enum TreatMissingData {
	/**
	 * Missing data points are treated as breaching the threshold
	 */
	BREACHING = "breaching",
	/**
	 * Missing data points are treated as being within the threshold
	 */
	NOT_BREACHING = "notBreaching",
	/**
	 * The current alarm state is maintained
	 */
	IGNORE = "ignore",
	/**
	 * The alarm does not consider missing data points when evaluating whether to change state
	 */
	MISSING = "missing"
}
declare class Alarm extends AlarmBase {
	/**
	 * Import an existing CloudWatch alarm provided an ARN
	 *
	 * @param scope The parent creating construct (usually `this`).
	 * @param id The construct's name
	 * @param alarmArn Alarm ARN (i.e. arn:aws:cloudwatch:<region>:<account-id>:alarm:Foo)
	 */
	static fromAlarmArn(scope: Construct, id: string, alarmArn: string): IAlarm;
	/**
	 * ARN of this alarm
	 *
	 * @attribute
	 */
	readonly alarmArn: string;
	/**
	 * Name of this alarm.
	 *
	 * @attribute
	 */
	readonly alarmName: string;
	/**
	 * The metric object this alarm was based on
	 */
	readonly metric: IMetric;
	/**
	 * This metric as an annotation
	 */
	private readonly annotation;
	constructor(scope: Construct, id: string, props: AlarmProps);
	/**
	 * Turn this alarm into a horizontal annotation
	 *
	 * This is useful if you want to represent an Alarm in a non-AlarmWidget.
	 * An `AlarmWidget` can directly show an alarm, but it can only show a
	 * single alarm and no other metrics. Instead, you can convert the alarm to
	 * a HorizontalAnnotation and add it as an annotation to another graph.
	 *
	 * This might be useful if:
	 *
	 * - You want to show multiple alarms inside a single graph, for example if
	 *   you have both a "small margin/long period" alarm as well as a
	 *   "large margin/short period" alarm.
	 *
	 * - You want to show an Alarm line in a graph with multiple metrics in it.
	 */
	toAnnotation(): HorizontalAnnotation;
	/**
	 * Trigger this action if the alarm fires
	 *
	 * Typically the ARN of an SNS topic or ARN of an AutoScaling policy.
	 */
	addAlarmAction(...actions: IAlarmAction[]): void;
	private validateActionArn;
	private renderMetric;
	/**
	 * Validate that if a region is in the given stat config, they match the Alarm
	 */
	private validateMetricStat;
	/**
	 * Validates that the expression config does not specify searchAccount or searchRegion props
	 * as search expressions are not supported by Alarms.
	 */
	private validateMetricExpression;
	/**
	 * Determine if the accountId property should be included in the metric.
	 */
	private requiresAccountId;
}
export interface IQueue {
	/**
	 * Return the given named metric for this Queue
	 */
	metric(metricName: string, props?: cloudwatch.MetricOptions): cloudwatch.Metric;
	/**
	 * The approximate age of the oldest non-deleted message in the queue.
	 *
	 * Maximum over 5 minutes
	 */
	metricApproximateAgeOfOldestMessage(props?: cloudwatch.MetricOptions): cloudwatch.Metric;
	/**
	 * The number of messages in the queue that are delayed and not available for reading immediately.
	 *
	 * Maximum over 5 minutes
	 */
	metricApproximateNumberOfMessagesDelayed(props?: cloudwatch.MetricOptions): cloudwatch.Metric;
	/**
	 * The number of messages that are in flight.
	 *
	 * Maximum over 5 minutes
	 */
	metricApproximateNumberOfMessagesNotVisible(props?: cloudwatch.MetricOptions): cloudwatch.Metric;
	/**
	 * The number of messages available for retrieval from the queue.
	 *
	 * Maximum over 5 minutes
	 */
	metricApproximateNumberOfMessagesVisible(props?: cloudwatch.MetricOptions): cloudwatch.Metric;
	/**
	 * The number of ReceiveMessage API calls that did not return a message.
	 *
	 * Sum over 5 minutes
	 */
	metricNumberOfEmptyReceives(props?: cloudwatch.MetricOptions): cloudwatch.Metric;
	/**
	 * The number of messages deleted from the queue.
	 *
	 * Sum over 5 minutes
	 */
	metricNumberOfMessagesDeleted(props?: cloudwatch.MetricOptions): cloudwatch.Metric;
	/**
	 * The number of messages returned by calls to the ReceiveMessage action.
	 *
	 * Sum over 5 minutes
	 */
	metricNumberOfMessagesReceived(props?: cloudwatch.MetricOptions): cloudwatch.Metric;
	/**
	 * The number of messages added to a queue.
	 *
	 * Sum over 5 minutes
	 */
	metricNumberOfMessagesSent(props?: cloudwatch.MetricOptions): cloudwatch.Metric;
	/**
	 * The size of messages added to a queue.
	 *
	 * Average over 5 minutes
	 */
	metricSentMessageSize(props?: cloudwatch.MetricOptions): cloudwatch.Metric;
}
export interface QueueBase {
	/**
	 * Return the given named metric for this Queue
	 */
	metric(metricName: string, props?: cloudwatch.MetricOptions): cloudwatch.Metric;
	/**
	 * The approximate age of the oldest non-deleted message in the queue.
	 *
	 * Maximum over 5 minutes
	 */
	metricApproximateAgeOfOldestMessage(props?: cloudwatch.MetricOptions): cloudwatch.Metric;
	/**
	 * The number of messages in the queue that are delayed and not available for reading immediately.
	 *
	 * Maximum over 5 minutes
	 */
	metricApproximateNumberOfMessagesDelayed(props?: cloudwatch.MetricOptions): cloudwatch.Metric;
	/**
	 * The number of messages that are in flight.
	 *
	 * Maximum over 5 minutes
	 */
	metricApproximateNumberOfMessagesNotVisible(props?: cloudwatch.MetricOptions): cloudwatch.Metric;
	/**
	 * The number of messages available for retrieval from the queue.
	 *
	 * Maximum over 5 minutes
	 */
	metricApproximateNumberOfMessagesVisible(props?: cloudwatch.MetricOptions): cloudwatch.Metric;
	/**
	 * The number of ReceiveMessage API calls that did not return a message.
	 *
	 * Sum over 5 minutes
	 */
	metricNumberOfEmptyReceives(props?: cloudwatch.MetricOptions): cloudwatch.Metric;
	/**
	 * The number of messages deleted from the queue.
	 *
	 * Sum over 5 minutes
	 */
	metricNumberOfMessagesDeleted(props?: cloudwatch.MetricOptions): cloudwatch.Metric;
	/**
	 * The number of messages returned by calls to the ReceiveMessage action.
	 *
	 * Sum over 5 minutes
	 */
	metricNumberOfMessagesReceived(props?: cloudwatch.MetricOptions): cloudwatch.Metric;
	/**
	 * The number of messages added to a queue.
	 *
	 * Sum over 5 minutes
	 */
	metricNumberOfMessagesSent(props?: cloudwatch.MetricOptions): cloudwatch.Metric;
	/**
	 * The size of messages added to a queue.
	 *
	 * Average over 5 minutes
	 */
	metricSentMessageSize(props?: cloudwatch.MetricOptions): cloudwatch.Metric;
}
declare class Queue extends sqs.Queue {
}
declare const _default: typeof sqs & {
	Queue: typeof Queue;
};

export {
	_default as sqs,
};

export {};
